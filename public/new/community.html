<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Life Swap - Community</title>
  <link rel="stylesheet" href="community.css">
  <link rel="stylesheet" href="./customHeader.css">
</head>
<body>
  <div class="community-page">
    <div class="top-bar">
      <a href="./start.html" class="button-link">Go back</a>
      <div class="community-info">
        <h2 id="communityName"></h2>
        <p id="communityMeta">Created: <span id="createdAt"></span> by <span id="creatorName"></span></p>
      </div>
      <button id="viewCommunitiesBtn">View Communities</button>
      <button id="viewNotificationsBtn">Notifications <span id="notificationCount" class="notification-badge">0</span></button>
    </div>
    <p>Share with friends!</p>
    <p id="communityId"></p>
    <button class="copy-btn" id="copyCommunityIdBtn">Copy Community ID</button>
    <p>Total Users: <span id="totalUsers">0</span> | Banned Users: <span id="bannedUsers">0</span> | <span id="profileRequestsBtn"></span></p>
    <div id="communityActions"></div>

    <!-- New Post Form (Toggle) -->
    <details>
      <summary>New Post</summary>
      <div>
        <form id="newPostForm">
          <input type="text" id="postTitle" placeholder="Title" required>
          <textarea id="postDescription" placeholder="Description" required></textarea>
          <input type="file" id="postPhotos" multiple accept="image/*">
          <input type="text" id="postLocation" placeholder="Location" required>
          <div id="postLocationSuggestions" class="suggestions"></div>
          <div class="community-checkbox-container">
            <label>Post to Communities:</label>
            <div id="communityCheckboxes" class="community-checkboxes">
              <!-- Checkboxes populated dynamically -->
            </div>
          </div>
          <label for="lookingFor">What are you looking for?</label>
          <select id="lookingFor" required>
            <option value="">Select an option</option>
            <option value="Time">Time</option>
            <option value="Skill">Skill</option>
            <option value="Item">Item</option>
          </select>
          <label for="offering">What are you offering?</label>
          <select id="offering" required>
            <option value="">Select an option</option>
            <option value="Time">Time</option>
            <option value="Skill">Skill</option>
            <option value="Item">Item</option>
          </select>
          <label for="category">Category:</label>
          <select id="category" required>
            <option value="" disabled selected>Select Category</option>
            <option value="clothing_accessories">Clothing & Accessories</option>
            <option value="electronics">Electronics & Gadgets</option>
            <option value="furniture_decor">Furniture & Home Decor</option>
            <option value="kitchen_dining">Kitchen & Dining</option>
            <option value="tools_diy">Tools & DIY</option>
            <option value="books_media">Books, Movies & Music</option>
            <option value="arts_crafts">Arts & Crafts</option>
            <option value="toys_games">Toys & Games</option>
            <option value="sports_outdoors">Sports & Outdoors</option>
            <option value="health_beauty">Health & Beauty</option>
            <option value="baby_kids">Baby & Kids</option>
            <option value="pet_supplies">Pet Supplies</option>
            <option value="misc">Miscellaneous</option>
          </select>
          <button type="button" id="createPostBtn">Create Post</button>
        </form>
      </div>
    </details>

    <!-- Your Posts (Toggle) -->
    <details>
      <summary>Your Posts</summary>
      <div id="yourPostsList"></div>
    </details>

    <!-- Community Posts Carousel -->
<div id="postsCarousel" class="posts-carousel">
  <h3>Quick View (Posts)</h3>
  <button class="carousel-arrow prev" id="carouselPrevBtn">&lt;</button>
  <div class="carousel-track" id="carouselTrack">
    <!-- Posts populated dynamically -->
  </div>
  <button class="carousel-arrow next" id="carouselNextBtn">&gt;</button>
</div>

    <!-- Community Posts -->
    <div id="posts">
      <h3>Community Posts</h3>
      <div class="post-filter-bar">
        <label for="categoryFilter">Category:</label>
        <select id="categoryFilter">
          <option value="">All</option>
          <option value="clothing_accessories">Clothing & Accessories</option>
          <option value="electronics">Electronics & Gadgets</option>
          <option value="furniture_decor">Furniture & Home Decor</option>
          <option value="kitchen_dining">Kitchen & Dining</option>
          <option value="tools_diy">Tools & DIY</option>
          <option value="books_media">Books, Movies & Music</option>
          <option value="arts_crafts">Arts & Crafts</option>
          <option value="toys_games">Toys & Games</option>
          <option value="sports_outdoors">Sports & Outdoors</option>
          <option value="health_beauty">Health & Beauty</option>
          <option value="baby_kids">Baby & Kids</option>
          <option value="pet_supplies">Pet Supplies</option>
          <option value="misc">Miscellaneous</option>
        </select>
        <label for="lookingForFilter">Looking For:</label>
        <select id="lookingForFilter">
          <option value="">All</option>
          <option value="Time">Time</option>
          <option value="Skill">Skill</option>
          <option value="Item">Item</option>
        </select>
        <label for="offeringFilter">Offering:</label>
        <select id="offeringFilter">
          <option value="">All</option>
          <option value="Time">Time</option>
          <option value="Skill">Skill</option>
          <option value="Item">Item</option>
        </select>
      </div>
      <div class="search-bar">
        <input type="text" id="postSearch" placeholder="Search by Post ID...">
      </div>
      <button id="refreshPostsBtn">Refresh Posts</button>
      <div id="postList"></div>
      <div id="caughtUpMessage" class="caught-up" style="display: none;">You are all caught up!</div>
      <div id="sentinel" style="height: 1px;"></div>
      <div class="pagination" id="postPagination"></div>
    </div>

  <!-- View Profile Modal -->
  <div id="viewProfileModal" class="modal hidden">
    <div class="modal-content">
      <h2 id="profileName"></h2>
      <img id="profilePhoto" src="" class="profile-photo" alt="Profile">
      <div id="profileDetails"></div>
      <div id="profileActions"></div>
      <button id="closeProfileBtn">Close</button>
    </div>
  </div>

  <!-- View Members Modal -->
  <div id="viewMembersModal" class="modal hidden">
    <div class="modal-content">
      <h2>Members</h2>
      <input type="text" id="memberSearch" placeholder="Search members...">
      <div id="membersList" class="user-list"></div>
      <button id="seeMoreMembersBtn">See More</button>
      <button id="closeMembersBtn">Close</button>
    </div>
  </div>

  <!-- View Banned Users Modal -->
  <div id="viewBannedModal" class="modal hidden">
    <div class="modal-content">
      <h2>Banned Users</h2>
      <input type="text" id="bannedSearch" placeholder="Search banned users...">
      <div id="bannedList" class="user-list"></div>
      <button id="seeMoreBannedBtn">See More</button>
      <button id="closeBannedBtn">Close</button>
    </div>
  </div>

  <!-- View Profile View Requests Modal -->
  <div id="viewProfileViewRequestsModal" class="modal hidden">
    <div class="modal-content">
      <h2>Profile View Requests</h2>
      <div id="profileViewRequestsList" class="user-list"></div>
      <h2>Granted Profile Access</h2>
      <div id="grantedProfileAccessList" class="user-list"></div>
      <button id="closeProfileViewRequestsBtn">Close</button>
    </div>
  </div>

  <!-- View Communities Modal -->
<div id="viewCommunitiesModal" class="modal hidden">
  <div class="modal-content">
    <h2>Your Communities</h2>
    <div id="communitiesList" class="user-list"></div>
    <button id="closeCommunitiesBtn">Close</button>
  </div>
</div>

<!-- Notifications Modal -->
<div id="notificationsModal" class="modal hidden">
  <div class="modal-content">
    <h2>Notifications <span id="modalNotificationCount">0</span></h2>
    <div class="notifications-filter">
      <label for="communityFilter">Filter by Community:</label>
      <select id="communityFilter">
        <option value="all">All Communities</option>
        <!-- Options populated dynamically -->
      </select>
      <button id="goToCommunityBtn" style="display: none;">Go to Community</button>
    </div>
    <div id="notificationList" class="notification-list"></div>
    <button id="clearNotificationsBtn">Clear Notifications</button>
    <button id="closeNotificationsBtn">Close</button>
  </div>
</div>

  <!-- Autocomplete Suggestions for @ Tagging -->
  <div id="tagSuggestions" class="suggestions hidden"></div>

  <script type="module" src="./customHeader.js"></script>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, updateDoc, addDoc, collection, query, where, getDocs, limit, deleteDoc, limitToLast, startAfter, orderBy, enableIndexedDbPersistence } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB5Q0kHoViWJl-t-pWCKj_AT-ClAMadfrU",
      authDomain: "life-swap-6065e.firebaseapp.com",
      projectId: "life-swap-6065e",
      storageBucket: "life-swap-6065e.firebasestorage.app",
      messagingSenderId: "475311181000",
      appId: "1:475311181000:web:32d03d80f70081bfb629fd",
      measurementId: "G-CHJY2ZEYYF"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const storage = getStorage(app);

// Enable offline persistence
enableIndexedDbPersistence(db)
  .then(() => {
    console.log("Offline persistence enabled successfully!");
  })
  .catch((err) => {
    if (err.code === "failed-precondition") {
      console.warn("Persistence failed: Multiple tabs open. Only one tab can enable persistence.");
    } else if (err.code === "unimplemented") {
      console.warn("Persistence not available: Browser doesn’t support it.");
    } else {
      console.error("Persistence error:", err);
    }
  });

    let communityId;
    let userDataCache = {};
    let currentPage = 1;
    const postsPerPage = 10;
    const itemsPerPage = 10;
    let lastMemberDoc = null;
    let lastBannedDoc = null;
    let carouselPostIds = []; // Store post IDs for navigation
    let carouselIndex = 0; // Current start index
    const postsPerCarousel = window.innerWidth < 768 ? 2 : 4; // 2 on mobile, 4 on desktop
    let isLoading = false;
    let lastPostDoc = null;
    let totalPosts = 0;
    const postsPerLoad = 10; // 10 posts per scroll
    let loadedPostIds = new Set();
    let initialPostsLoaded = false;
    let isSearching = false; // Flag to track if we're in search mode
    let postCache = new Map(); // Add this near your other globals (e.g., after userDataCache)
    const POSTS_PER_LOAD = 20; // Bigger batch size
    let isFetching = false; 

    document.addEventListener("DOMContentLoaded", () => {
  onAuthStateChanged(auth, async (user) => {
    if (!user) {
      window.location.href = "/login.html";
    } else {
      const urlParams = new URLSearchParams(window.location.search);
      communityId = urlParams.get("id");
      if (!communityId) {
        window.location.href = "/index.html";
        return;
      }

      const commRef = doc(db, "communities", communityId);
      const commDoc = await getDoc(commRef);
      if (commDoc.exists()) {
        const commData = commDoc.data();
        const isMember = commData.members.includes(user.uid);
        const isBanned = (commData.bannedUsers || []).includes(user.uid);

        if (isBanned) {
          // Fetch community data and ban reason
          const commRef = doc(db, "communities", communityId);
          const commDoc = await getDoc(commRef);
          const commData = commDoc.data();
          let adminEmail = "No admin email available";
          let banReason = commData.banReasons?.[user.uid] || "No reason provided";

          // Try creator first
          if (commData.creatorId) {
            const creatorDoc = await getDoc(doc(db, "users", commData.creatorId));
            if (creatorDoc.exists() && creatorDoc.data().email) {
              adminEmail = creatorDoc.data().email;
            }
          }

          // If no creator email, try admins
          if (adminEmail === "No admin email available" && commData.admins?.length > 0) {
            const adminDoc = await getDoc(doc(db, "users", commData.admins[0]));
            if (adminDoc.exists() && adminDoc.data().email) {
              adminEmail = adminDoc.data().email;
            }
          }

          document.querySelector(".community-page").innerHTML = `
            <div class="ban-message">
              <h2>You are banned from this community!</h2>
              <p><strong>Reason:</strong> ${banReason}</p>
              <p>Think this is a mistake? Send an appeal below or contact an admin at: ${adminEmail}</p>
              <form id="banAppealForm" class="ban-appeal-form">
                <textarea placeholder="Explain why this ban might be an error..." required></textarea>
                <button type="submit">Send Appeal</button>
              </form>
              <p><a href="./start.html">Go back</a></p>
            </div>
          `;
          const appealForm = document.getElementById("banAppealForm");
          appealForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            const text = appealForm.querySelector("textarea").value.trim();
            if (text) {
              await addDoc(collection(db, "banAppeals"), {
                userId: user.uid,
                communityId: communityId,
                message: text,
                timestamp: new Date()
              });
              alert("Appeal sent!");
              appealForm.querySelector("textarea").disabled = true;
              appealForm.querySelector("button").disabled = true;
              appealForm.querySelector("button").textContent = "Appeal Sent";
            }
          });
          return;
        } else if (!isMember) {
          document.querySelector(".community-page").innerHTML = `
            <div class="not-member-message">
              <h2>You aren't a member of this community.</h2>
              <p><a href="./start.html">Go back</a></p>
            </div>
          `;
          return;
        }

        // Set community name, creation date, and creator name
        document.getElementById("communityName").textContent = commData.name;
        const createdAt = commData.createdAt ? new Date(commData.createdAt.toDate()).toLocaleString() : "N/A";
        document.getElementById("createdAt").textContent = createdAt;
        const creatorData = await fetchUserData(commData.creatorId);
        document.getElementById("creatorName").textContent = creatorData.name || "Unknown";
        document.getElementById("creatorName").addEventListener("click", () => viewProfile(commData.creatorId));

        document.getElementById("communityId").textContent = `ID: ${communityId}`;
        document.getElementById("totalUsers").textContent = commData.members.length;
        document.getElementById("bannedUsers").textContent = (commData.bannedUsers || []).length;

        const actions = document.getElementById("communityActions");
        const profileViewRequestsQ = query(collection(db, "profileRequests"), where("targetId", "==", user.uid), where("status", "==", "pending"));
        const profileViewRequestsSnapshot = await getDocs(profileViewRequestsQ);
        const profileViewRequestCount = profileViewRequestsSnapshot.size;
        actions.innerHTML = `
          <button id="viewMembersBtn">View Members</button>
          ${(commData.admins && commData.admins.includes(user.uid)) || commData.creatorId === user.uid ? `<button id="viewBannedBtn">View Banned</button>` : ""}
          ${commData.creatorId === user.uid ? `<button class="delete-btn" id="deleteCommunityBtn">Delete Community</button>` : ""}
          ${commData.members.includes(user.uid) && commData.creatorId !== user.uid ? `<button class="leave-btn" id="leaveCommunityBtn">Leave Community</button>` : ""}
          <button id="viewProfileViewRequestsBtn">See Profile View Requests ${profileViewRequestCount > 0 ? `<span class="request-badge">${profileViewRequestCount}</span>` : ''}</button>
          ${(commData.admins && commData.admins.includes(user.uid)) || commData.creatorId === user.uid ? `<button id="editNameBtn">Edit Name (Community)</button>` : ""}
        `;

        await new Promise(resolve => setTimeout(resolve, 0));
        await updateProfileRequestsUI(user.uid);

        const postIdSearch = document.getElementById("postSearch");
        const categoryFilter = document.getElementById("categoryFilter");
        const lookingForFilter = document.getElementById("lookingForFilter");
        const offeringFilter = document.getElementById("offeringFilter");
        const carouselPrevBtn = document.getElementById("carouselPrevBtn");
        const carouselNextBtn = document.getElementById("carouselNextBtn");
        const copyCommunityIdBtn = document.getElementById("copyCommunityIdBtn");
        const createPostBtn = document.getElementById("createPostBtn");
        const viewMembersBtn = document.getElementById("viewMembersBtn");
        const viewBannedBtn = document.getElementById("viewBannedBtn");
        const deleteCommunityBtn = document.getElementById("deleteCommunityBtn");
        const leaveCommunityBtn = document.getElementById("leaveCommunityBtn");
        const viewProfileViewRequestsBtn = document.getElementById("viewProfileViewRequestsBtn");
        const closeProfileBtn = document.getElementById("closeProfileBtn");
        const closeMembersBtn = document.getElementById("closeMembersBtn");
        const closeBannedBtn = document.getElementById("closeBannedBtn");
        const closeProfileViewRequestsBtn = document.getElementById("closeProfileViewRequestsBtn");
        const viewNotificationsBtn = document.getElementById("viewNotificationsBtn");
        const closeNotificationsBtn = document.getElementById("closeNotificationsBtn");
        const clearNotificationsBtn = document.getElementById("clearNotificationsBtn");
        const refreshPostsBtn = document.getElementById("refreshPostsBtn");
        const editNameBtn = document.getElementById("editNameBtn");
        const viewCommunitiesBtn = document.getElementById("viewCommunitiesBtn");

        if (postIdSearch) {
          postIdSearch.addEventListener("input", debounce((e) => {
            searchPostsById(e.target.value);
          }, 300));
        }
        if (categoryFilter) {
          categoryFilter.addEventListener("change", () => {
            loadPosts(communityId, true);
            carouselIndex = 0;
            loadCarouselPosts(communityId);
          });
        }
        if (lookingForFilter) {
          lookingForFilter.addEventListener("change", () => {
            loadPosts(communityId, true);
            carouselIndex = 0;
            loadCarouselPosts(communityId);
          });
        }
        if (offeringFilter) {
          offeringFilter.addEventListener("change", () => {
            loadPosts(communityId, true);
            carouselIndex = 0;
            loadCarouselPosts(communityId);
          });
        }
        if (carouselPrevBtn) carouselPrevBtn.addEventListener("click", () => slideCarousel(-1));
        if (carouselNextBtn) carouselNextBtn.addEventListener("click", () => slideCarousel(1));
        if (copyCommunityIdBtn) copyCommunityIdBtn.addEventListener("click", copyCommunityId);
        if (createPostBtn) createPostBtn.addEventListener("click", createPost);
        if (viewMembersBtn) viewMembersBtn.addEventListener("click", () => viewMembers(communityId));
        if (viewBannedBtn) viewBannedBtn.addEventListener("click", () => viewBannedUsers(communityId));
        if (deleteCommunityBtn) deleteCommunityBtn.addEventListener("click", () => deleteCommunity(communityId));
        if (leaveCommunityBtn) leaveCommunityBtn.addEventListener("click", () => leaveCommunity(communityId));
        if (viewProfileViewRequestsBtn) viewProfileViewRequestsBtn.addEventListener("click", () => viewProfileViewRequests(user.uid));
        if (closeProfileBtn) closeProfileBtn.addEventListener("click", () => closeModal("viewProfileModal"));
        if (closeMembersBtn) closeMembersBtn.addEventListener("click", () => closeModal("viewMembersModal"));
        if (closeBannedBtn) closeBannedBtn.addEventListener("click", () => closeModal("viewBannedModal"));
        if (closeProfileViewRequestsBtn) closeProfileViewRequestsBtn.addEventListener("click", () => closeModal("viewProfileViewRequestsModal"));
        if (viewNotificationsBtn) viewNotificationsBtn.addEventListener("click", () => openNotificationsModal(user.uid));
        if (closeNotificationsBtn) closeNotificationsBtn.addEventListener("click", () => closeModal("notificationsModal"));
        if (clearNotificationsBtn) clearNotificationsBtn.addEventListener("click", clearNotifications);
        if (refreshPostsBtn) refreshPostsBtn.addEventListener("click", () => loadPosts(communityId, true));
        if (editNameBtn) editNameBtn.addEventListener("click", () => editCommunityName(communityId));
        if (viewCommunitiesBtn) viewCommunitiesBtn.addEventListener("click", () => viewCommunities(user.uid));

        setupLocationAutocomplete();
        setupCommunitySelection();
        loadYourPosts(user.uid);
        loadPosts(communityId, false);
        setupInfiniteScroll();
        loadCarouselPosts(communityId);
        updateNotificationBadge(user.uid);
        await loadAdminReportSummary();
      } else {
        alert("Community not found!");
        window.location.href = "/index.html";
      }
    }
  });
});

async function updateProfileRequestsUI(userId) {
  const requestsQ = query(collection(db, "profileRequests"), where("targetId", "==", userId), where("status", "==", "pending"));
  const requestsSnapshot = await getDocs(requestsQ);
  const requestCount = requestsSnapshot.size;
  const profileRequestsBtn = document.getElementById("profileRequestsBtn");
  if (profileRequestsBtn) {
    profileRequestsBtn.innerHTML = requestCount > 0 ? `<button id="viewRequestsBtn">Profile Requests (${requestCount})</button>` : "";
  } else {
    console.error("profileRequestsBtn not found in DOM");
  }
  if (document.getElementById("viewRequestsBtn")) {
    document.getElementById("viewRequestsBtn").addEventListener("click", () => viewProfileViewRequests(userId));
  }
  const actions = document.getElementById("communityActions");
  if (actions) {
    const profileViewRequestsQ = query(collection(db, "profileRequests"), where("targetId", "==", userId), where("status", "==", "pending"));
    const profileViewRequestsSnapshot = await getDocs(profileViewRequestsQ);
    const profileViewRequestCount = profileViewRequestsSnapshot.size;
    const viewProfileViewRequestsBtn = actions.querySelector("#viewProfileViewRequestsBtn");
    if (viewProfileViewRequestsBtn) {
      viewProfileViewRequestsBtn.innerHTML = `See Profile View Requests ${profileViewRequestCount > 0 ? `<span class="request-badge">${profileViewRequestCount}</span>` : ''}`;
    }
  }
}

    function closeModal(modalId) {
      const modal = document.getElementById(modalId);
      modal.classList.add("hidden");
      modal.style.display = "none";
      const lowerModals = Array.from(document.querySelectorAll(".modal:not(.hidden)"));
      if (lowerModals.length > 0) lowerModals[lowerModals.length - 1].style.display = "flex";
      document.querySelectorAll(".suggestions").forEach(div => div.classList.add("hidden"));
    }

    function copyCommunityId() {
      navigator.clipboard.writeText(communityId).then(() => alert("Community ID copied!")).catch(err => console.error("Failed to copy:", err));
    }

    function copyPostId(postId) {
      navigator.clipboard.writeText(postId).then(() => alert("Post ID copied!")).catch(err => console.error("Failed to copy:", err));
    }

    async function deleteCommunity(communityId) {
      if (confirm("Are you sure you want to delete this community? This can’t be undone!")) {
        const commRef = doc(db, "communities", communityId);
        await updateDoc(commRef, { deleted: true });
        window.location.href = "/index.html";
      }
    }

    async function leaveCommunity(communityId) {
      if (confirm("Are you sure you want to leave this community?")) {
        const user = auth.currentUser;
        const userRef = doc(db, "users", user.uid);
        const commRef = doc(db, "communities", communityId);
        const userDoc = await getDoc(userRef);
        const commDoc = await getDoc(commRef);

        const communityIds = userDoc.data().communityIds.filter(id => id !== communityId);
        await updateDoc(userRef, { communityIds });

        const members = commDoc.data().members.filter(uid => uid !== user.uid);
        await updateDoc(commRef, { members });

        window.location.href = "/index.html";
      }
    }

    async function fetchCurrentUserData() {
  const user = auth.currentUser;
  const cacheKey = "currentUserData";
  let currentUserData = JSON.parse(sessionStorage.getItem(cacheKey));

  if (currentUserData && currentUserData.uid === user.uid) {
    //console.log(`Cache hit for current user uid ${user.uid}:`, currentUserData);
    return currentUserData;
  }

  const userRef = doc(db, "users", user.uid);
  const userDoc = await getDoc(userRef);

  if (!userDoc.exists()) {
    console.log(`No user doc found for current uid ${user.uid}`);
    const fallbackData = { 
      name: "Unknown", 
      username: "unknown", 
      profilePhoto: null, 
      email: null, 
      city: null, 
      phone: null, 
      uid: user.uid 
    };
    sessionStorage.setItem(cacheKey, JSON.stringify(fallbackData));
    return fallbackData;
  }

  const userData = userDoc.data();
  //console.log(`Fetched current user data for uid ${user.uid}:`, userData);

  const cachedData = {
    name: userData.name || "Unknown",
    username: userData.username || "unknown",
    profilePhoto: userData.profilePhoto || null,
    email: userData.email || null,
    city: userData.city || null,
    phone: userData.phone || null,
    uid: user.uid
  };

  sessionStorage.setItem(cacheKey, JSON.stringify(cachedData));
  return cachedData;
}

async function fetchUserData(uids) {
  if (!uids) return { name: "Unknown", username: "unknown", profilePhoto: "https://via.placeholder.com/40", uid: "unknown" };
  const uidArray = Array.isArray(uids) ? uids : [uids];
  
  // Check cache first, only fetch what’s missing
  const uncachedUids = uidArray.filter(uid => !userDataCache[uid] || userDataCache[uid].name === "Unknown");
  if (uncachedUids.length > 0) {
    const batches = [];
    for (let i = 0; i < uncachedUids.length; i += 10) {
      batches.push(uncachedUids.slice(i, i + 10)); // Batch in groups of 10 (Firestore "in" limit)
    }
    
    for (const batch of batches) {
      const q = query(collection(db, "users"), where("__name__", "in", batch));
      const snapshot = await getDocs(q);
      snapshot.forEach(doc => {
        const data = doc.data();
        userDataCache[doc.id] = {
          name: data.name || "Unknown",
          username: data.username || "unknown",
          profilePhoto: data.profilePhoto || "https://via.placeholder.com/40",
          email: data.email || null,
          city: data.city || null,
          phone: data.phone || null,
          uid: doc.id
        };
        userDataCache[`username:${data.username}`] = userDataCache[doc.id];
      });
      
      // Fallback for any UIDs not found in this batch
      batch.forEach(uid => {
        if (!userDataCache[uid]) {
          userDataCache[uid] = { name: "Unknown", username: "unknown", profilePhoto: "https://via.placeholder.com/40", uid };
        }
      });
    }
  }
  
  // Return from cache
  return uidArray.length === 1 ? userDataCache[uidArray[0]] : uidArray.map(uid => userDataCache[uid]);
}

// Add these helper functions right after your existing functions like `fetchUserData` or `createPost`
async function getPostReportStatus(postId) {
  const reportsRef = collection(db, "communities", communityId, "postReports");
  const q = query(reportsRef, where("postId", "==", postId));
  const snapshot = await getDocs(q);
  const reportCount = snapshot.size;
  const commData = await getCommData();
  const user = auth.currentUser;
  const isAdmin = commData.admins?.includes(user.uid) || commData.creatorId === user.uid;
  const postRef = doc(db, "communities", communityId, "posts", postId);
  const postDoc = await getDoc(postRef);
  const postData = postDoc.data();
  const isOwner = postData.userId === user.uid;

  return {
    reportCount,
    isHidden: reportCount >= 2 && !isAdmin && !isOwner, // Hide only at 2+ reports for non-admins/non-owners
    isAdmin,
    isOwner
  };
}

async function reportPost(postId) {
  const user = auth.currentUser;
  const reportsRef = collection(db, "communities", communityId, "postReports");
  const existingReportQ = query(reportsRef, where("postId", "==", postId), where("reporterId", "==", user.uid));
  const existingReportSnapshot = await getDocs(existingReportQ);

  if (!existingReportSnapshot.empty) {
    alert("You’ve already reported this post!");
    return;
  }

  if (!confirm("Are you sure you want to report this post?")) {
    return; // User canceled
  }

  // Add the report to Firestore
  await addDoc(reportsRef, {
    postId,
    reporterId: user.uid,
    communityId,
    timestamp: new Date()
  });

  alert("Post reported!");
  refreshReportSummary(); // Add this

  // Update UI without refreshing
  const postDiv = document.getElementById(`post-${postId}`);
  const reportStatus = await getPostReportStatus(postId);
  const commData = await getCommData();
  const isAdmin = commData.admins?.includes(user.uid) || commData.creatorId === user.uid;

  if (postDiv) {
    // Update report-related UI
    const existingWarning = postDiv.querySelector(".report-warning");
    const existingAdminControls = postDiv.querySelector(".admin-report-controls");

    // Remove existing report UI elements if they exist
    if (existingWarning) existingWarning.remove();
    if (existingAdminControls) existingAdminControls.remove();

    // Hide post for non-admins/non-owners if it has 2+ reports
    if (reportStatus.isHidden) {
      postDiv.remove(); // Remove from community posts if hidden
      return;
    }

    // Add warning for post owner
    if (reportStatus.isOwner) {
      if (reportStatus.reportCount === 1) {
        postDiv.insertAdjacentHTML(
          "beforeend",
          `<div class="report-warning" id="warning-${postId}">
            This post has 1 report. One more will hide it from others—check it in the summary above!
          </div>`
        );
      } else if (reportStatus.reportCount >= 2) {
        postDiv.insertAdjacentHTML(
          "beforeend",
          `<div class="report-warning" id="warning-${postId}">
            This post has ${reportStatus.reportCount} reports and is hidden from others. Appeal in the summary above!
          </div>`
        );
      }
    }

    // Add admin controls if user is an admin
    if (isAdmin && reportStatus.reportCount > 0) {
      postDiv.insertAdjacentHTML(
        "beforeend",
        `<div class="admin-report-controls" id="admin-controls-${postId}">
          This post received ${reportStatus.reportCount} report${reportStatus.reportCount > 1 ? 's' : ''}.
          <button class="remove-post-btn" data-post-id="${postId}">Remove Post</button>
          <button class="clear-reports-btn" data-post-id="${postId}">Clear Reports</button>
        </div>`
      );
      postDiv.querySelector(`.remove-post-btn[data-post-id="${postId}"]`).addEventListener("click", () => deletePost(postId));
      postDiv.querySelector(`.clear-reports-btn[data-post-id="${postId}"]`).addEventListener("click", () => clearReports(postId));
    }
  }

  // Update "Your Posts" section if visible
  const yourPostDiv = document.querySelector(`#yourPostsList #post-${postId}`);
  if (yourPostDiv) {
    const existingWarning = yourPostDiv.querySelector(".report-warning");
    if (existingWarning) existingWarning.remove();

    if (reportStatus.isOwner) {
      if (reportStatus.reportCount === 1) {
        yourPostDiv.insertAdjacentHTML(
          "beforeend",
          `<div class="report-warning" id="warning-${postId}">
            This post has 1 report. One more will hide it from others—check it in the summary above!
          </div>`
        );
      } else if (reportStatus.reportCount >= 2) {
        yourPostDiv.insertAdjacentHTML(
          "beforeend",
          `<div class="report-warning" id="warning-${postId}">
            This post has ${reportStatus.reportCount} reports and is hidden from others. Appeal in the summary above!
          </div>`
        );
      }
    }
  }

  // Update admin summary
  await loadAdminReportSummary();
}

async function clearReports(postId) {
  if (confirm("Clear all reports for this post? It’ll be visible again.")) {
    const reportsRef = collection(db, "communities", communityId, "postReports");
    const q = query(reportsRef, where("postId", "==", postId));
    const snapshot = await getDocs(q);
    const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));
    await Promise.all(deletePromises);
    loadPosts(communityId, currentPage);
    loadCarouselPosts(communityId);
  }
}

    async function compressImage(file) {
      return new Promise((resolve) => {
        const img = new Image();
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        img.onload = () => {
          const maxWidth = 800;
          const maxHeight = 800;
          let width = img.width;
          let height = img.height;

          if (width > height) {
            if (width > maxWidth) {
              height *= maxWidth / width;
              width = maxWidth;
            }
          } else {
            if (height > maxHeight) {
              width *= maxHeight / height;
              height = maxHeight;
            }
          }

          canvas.width = width;
          canvas.height = height;
          ctx.drawImage(img, 0, 0, width, height);
          canvas.toBlob((blob) => resolve(blob), "image/jpeg", 0.7);
        };
        img.src = URL.createObjectURL(file);
      });
    }

    function setupLocationAutocomplete() {
  const locationInput = document.getElementById("postLocation");
  const suggestionsDiv = document.getElementById("postLocationSuggestions");

  if (!locationInput || !suggestionsDiv) {
    console.error("Location input or suggestions div not found!");
    return;
  }

  //console.log("Setting up location autocomplete for postLocation");

  locationInput.oninput = debounce(async () => {
    const query = locationInput.value.trim();
    console.log(`Querying Nominatim with: ${query}`);
    if (query.length < 2) {
      suggestionsDiv.innerHTML = "";
      suggestionsDiv.classList.add("hidden");
      return;
    }

    const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=5&addressdetails=1`;
    try {
      const response = await fetch(url, { headers: { "User-Agent": "LifeSwap/1.0 (your-email@example.com)" } });
      const data = await response.json();
      console.log("Nominatim response:", data);

      suggestionsDiv.innerHTML = "";
      if (data.length > 0) {
        suggestionsDiv.classList.remove("hidden");
        const inputRect = locationInput.getBoundingClientRect();
        suggestionsDiv.style.position = "absolute";
        suggestionsDiv.style.left = `${inputRect.left}px`;
        suggestionsDiv.style.top = `${inputRect.bottom + window.scrollY}px`;
        suggestionsDiv.style.width = `${inputRect.width}px`; // Match input width

        data.forEach((place) => {
          const city = place.address.city || place.address.town || place.address.village || place.address.hamlet || "";
          const state = place.address.state || "";
          const country = place.address.country || "";
          const region = state ? state : country;
          const displayName = city && region ? `${city}, ${region}` : place.display_name;

          const suggestion = document.createElement("div");
          suggestion.classList.add("suggestion-item");
          suggestion.textContent = displayName;
          suggestion.onclick = () => {
            locationInput.value = displayName;
            locationInput.dataset.lat = place.lat;
            locationInput.dataset.lon = place.lon;
            suggestionsDiv.innerHTML = "";
            suggestionsDiv.classList.add("hidden");
            console.log(`Selected: ${displayName}, lat: ${place.lat}, lon: ${place.lon}`);
          };
          suggestionsDiv.appendChild(suggestion);
        });
        console.log("Suggestions displayed for postLocationSuggestions");
      } else {
        suggestionsDiv.classList.add("hidden");
      }
    } catch (error) {
      console.error("Error fetching location suggestions:", error);
      suggestionsDiv.classList.add("hidden");
    }
  }, 300);
}

async function editCommunityName(communityId) {
  const commRef = doc(db, "communities", communityId);
  const commDoc = await getDoc(commRef);
  const commData = commDoc.data();
  const currentName = commData.name;

  // Create a simple form in the DOM
  const form = document.createElement("div");
  form.id = "edit-name-form";
  form.style.position = "fixed";
  form.style.top = "50%";
  form.style.left = "50%";
  form.style.transform = "translate(-50%, -50%)";
  form.style.background = "#fff";
  form.style.padding = "20px";
  form.style.border = "1px solid #ccc";
  form.style.boxShadow = "0 0 10px rgba(0,0,0,0.2)";
  form.style.zIndex = "1000";
  form.innerHTML = `
    <h3>Edit Community Name</h3>
    <input type="text" id="newCommunityName" value="${currentName}" style="width: 100%; margin-bottom: 10px;">
    <button id="saveNameBtn">Save</button>
    <button id="cancelNameBtn">Cancel</button>
  `;
  document.body.appendChild(form);

  // Event listeners
  document.getElementById("saveNameBtn").addEventListener("click", async () => {
    const newName = document.getElementById("newCommunityName").value.trim();
    if (!newName) {
      alert("Name can’t be empty!");
      return;
    }
    if (newName === currentName) {
      alert("That’s already the name!");
      document.body.removeChild(form);
      return;
    }

    await updateDoc(commRef, { name: newName });
    document.getElementById("communityName").textContent = newName;
    document.body.removeChild(form);
    alert("Community name updated!");
  });

  document.getElementById("cancelNameBtn").addEventListener("click", () => {
    document.body.removeChild(form);
  });
}

let reportSummaryCache = null;

async function loadAdminReportSummary() {
  const commData = await getCommData();
  const user = auth.currentUser;
  const isAdmin = commData.admins?.includes(user.uid) || commData.creatorId === user.uid;

  let summaryDiv = document.getElementById("admin-report-summary");
  if (!summaryDiv) {
    summaryDiv = document.createElement("div");
    summaryDiv.id = "admin-report-summary";
    summaryDiv.className = "admin-report-summary";
    document.querySelector(".community-page").insertBefore(summaryDiv, document.querySelector(".top-bar").nextSibling);
  }

  // Use cache if available
  if (reportSummaryCache) {
    summaryDiv.innerHTML = reportSummaryCache.html;
    attachSummaryListeners(summaryDiv, isAdmin);
    console.log("Loaded report summary from cache!");
    return;
  }

  summaryDiv.innerHTML = '<div class="loading">Loading...</div>';
  const reportsRef = collection(db, "communities", communityId, "postReports");
  const reportsQ = query(reportsRef);
  const reportsSnapshot = await getDocs(reportsQ);
  const reportCount = Object.keys(reportsSnapshot.docs.reduce((acc, doc) => {
    acc[doc.data().postId] = true;
    return acc;
  }, {})).length;

  let appealCount = 0;
  if (isAdmin) {
    const appealsQ = query(collection(db, "banAppeals"), where("communityId", "==", communityId));
    const appealsSnapshot = await getDocs(appealsQ);
    appealCount = appealsSnapshot.size;
  } else {
    const userPostsQ = query(collection(db, "communities", communityId, "posts"), where("userId", "==", user.uid));
    const userPostsSnapshot = await getDocs(userPostsQ);
    const reportedPosts = [];
    for (const postDoc of userPostsSnapshot.docs) {
      const postId = postDoc.id;
      const reportQ = query(reportsRef, where("postId", "==", postId));
      const reportSnapshot = await getDocs(reportQ);
      if (!reportSnapshot.empty) reportedPosts.push(postId);
    }
    appealCount = reportedPosts.length;
  }

  const totalNotifications = reportCount + (isAdmin ? appealCount : 0);
  summaryDiv.innerHTML = `
    <details>
      <summary>${totalNotifications > 0 ? `(${totalNotifications}) ` : ''}See Reports</summary>
      <div id="report-content" class="report-content"></div>
    </details>
  `;
  reportSummaryCache = { html: summaryDiv.innerHTML };
  attachSummaryListeners(summaryDiv, isAdmin);
}

function attachSummaryListeners(summaryDiv, isAdmin) {
  const details = summaryDiv.querySelector("details");
  details.addEventListener("toggle", async () => {
    const contentDiv = summaryDiv.querySelector("#report-content");
    if (details.open) {
      contentDiv.innerHTML = '<div class="loading">Loading...</div>';
      details.querySelector("summary").textContent = `${reportSummaryCache.html.match(/\(\d+\)/) || ''}Hide Reports`;

      if (isAdmin) {
        const reportsRef = collection(db, "communities", communityId, "postReports");
        const reportsQ = query(reportsRef);
        const reportsSnapshot = await getDocs(reportsQ);
        if (reportsSnapshot.empty) {
          contentDiv.innerHTML = "<p>No reported posts!</p>";
        } else {
          const reportCounts = {};
          reportsSnapshot.forEach(doc => {
            const postId = doc.data().postId;
            reportCounts[postId] = (reportCounts[postId] || 0) + 1;
          });

          contentDiv.innerHTML = "<h3>Reported Posts</h3>";
          for (const [postId, count] of Object.entries(reportCounts)) {
            const postRef = doc(db, "communities", communityId, "posts", postId);
            const postDoc = await getDoc(postRef);
            const postData = postDoc.exists() ? postDoc.data() : null;
            const title = postData ? postData.title : "Deleted Post";
            const ownerData = postData ? await fetchUserData(postData.userId) : { name: "Unknown" };

            contentDiv.innerHTML += `
              <div class="report-item" data-post-id="${postId}">
                <span>Post "${title}" by ${ownerData.name} (ID: ${postId}) - ${count} report${count > 1 ? 's' : ''}</span>
                <button class="remove-post-btn" data-post-id="${postId}">Remove Post</button>
                <button class="clear-reports-btn" data-post-id="${postId}">Clear Reports</button>
              </div>
            `;
          }

          const appealsQ = query(collection(db, "banAppeals"), where("communityId", "==", communityId));
          const appealsSnapshot = await getDocs(appealsQ);
          if (!appealsSnapshot.empty) {
            contentDiv.innerHTML += "<h3>User Appeals</h3>";
            for (const doc of appealsSnapshot.docs) {
              const appeal = doc.data();
              const userData = await fetchUserData(appeal.userId);
              const postId = appeal.postId || "N/A";
              contentDiv.innerHTML += `
                <div class="appeal-item" data-appeal-id="${doc.id}">
                  <p><strong>${userData.name || "Unknown"}:</strong> "${appeal.message}" (Post ID: ${postId})</p>
                  <span>${new Date(appeal.timestamp.toDate()).toLocaleString()}</span>
                  <button class="delete-appeal-btn" data-appeal-id="${doc.id}">Delete</button>
                </div>
              `;
            }
          } else {
            contentDiv.innerHTML += "<h3>User Appeals</h3><p>No appeals yet, bro.</p>";
          }
        }
      } else {
        const userPostsQ = query(collection(db, "communities", communityId, "posts"), where("userId", "==", user.uid));
        const userPostsSnapshot = await getDocs(userPostsQ);
        const reportedPosts = [];

        for (const postDoc of userPostsSnapshot.docs) {
          const postId = postDoc.id;
          const reportQ = query(reportsRef, where("postId", "==", postId));
          const reportSnapshot = await getDocs(reportQ);
          if (!reportSnapshot.empty) {
            reportedPosts.push({ postId, title: postDoc.data().title, count: reportSnapshot.size });
          }
        }

        if (reportedPosts.length === 0) {
          contentDiv.innerHTML = "<p>No reports on your posts!</p>";
        } else {
          contentDiv.innerHTML = "<h3>Your Reported Posts</h3>";
          for (const post of reportedPosts) {
            const appealQ = query(collection(db, "banAppeals"), where("userId", "==", user.uid), where("postId", "==", post.postId));
            const appealSnapshot = await getDocs(appealQ);
            const hasAppeal = !appealSnapshot.empty;

            contentDiv.innerHTML += `
              <div class="report-item" data-post-id="${post.postId}">
                <p>Post "${post.title}" (ID: ${post.postId}) has ${post.count} report${post.count > 1 ? 's' : ''}</p>
                ${post.count >= 2 ? '<p style="color: red;">Hidden from others!</p>' : ''}
                <div class="appeal-container" data-post-id="${post.postId}">
                  ${!hasAppeal ? `
                    <form class="appeal-form" data-post-id="${post.postId}">
                      <textarea placeholder="Appeal to admins (e.g., 'Not breaking rules because...')" required></textarea>
                      <button type="submit">Send Appeal</button>
                    </form>
                  ` : '<p>Appeal sent, waiting on admins.</p>'}
                </div>
              </div>
            `;
          }
        }
      }

      if (isAdmin) {
        contentDiv.querySelectorAll(".remove-post-btn").forEach(btn => {
          btn.addEventListener("click", () => deletePost(btn.dataset.postId));
        });
        contentDiv.querySelectorAll(".clear-reports-btn").forEach(btn => {
          btn.addEventListener("click", () => clearReports(btn.dataset.postId));
        });
        contentDiv.querySelectorAll(".delete-appeal-btn").forEach(btn => {
          btn.addEventListener("click", async () => {
            if (confirm("Delete this appeal, bro?")) {
              const appealId = btn.dataset.appealId;
              await deleteDoc(doc(db, "banAppeals", appealId));
              const appealItem = btn.closest(".appeal-item");
              if (appealItem) appealItem.remove();
              refreshReportSummary();
            }
          });
        });
      } else {
        contentDiv.querySelectorAll(".appeal-form").forEach(form => {
          form.addEventListener("submit", async (e) => {
            e.preventDefault();
            const postId = form.dataset.postId;
            const message = form.querySelector("textarea").value.trim();
            if (message) {
              await addDoc(collection(db, "banAppeals"), {
                userId: user.uid,
                communityId,
                postId,
                message,
                timestamp: new Date()
              });
              alert("Appeal sent!");
              const appealContainer = form.closest(".appeal-container");
              appealContainer.innerHTML = '<p>Appeal sent, waiting on admins.</p>';
              refreshReportSummary();
            }
          });
        });
      }
    } else {
      details.querySelector("summary").textContent = `${reportSummaryCache.html.match(/\(\d+\)/) || ''}See Reports`;
      contentDiv.innerHTML = "";
    }
  });
}

// Refresh cache when data changes
function refreshReportSummary() {
  reportSummaryCache = null;
  loadAdminReportSummary();
}

// Keep the debounced version
const debouncedLoadAdminReportSummary = debounce(loadAdminReportSummary, 500);

async function createPost() {
  const user = auth.currentUser;
  const title = document.getElementById("postTitle").value.trim();
  const description = document.getElementById("postDescription").value.trim();
  const photos = document.getElementById("postPhotos").files;
  const location = document.getElementById("postLocation").value.trim();
  const lat = document.getElementById("postLocation").dataset.lat;
  const lon = document.getElementById("postLocation").dataset.lon;
  const communityCheckboxes = document.querySelectorAll("#communityCheckboxes input[name='communities']:checked");
  const category = document.getElementById("category").value;
  const lookingFor = document.getElementById("lookingFor").value; // Fixed: Use form dropdown
  const offering = document.getElementById("offering").value;     // Fixed: Use form dropdown

  if (!title || !description || !location || !lat || !lon || !category || !lookingFor || !offering) {
    alert("Fill out all fields, pick a category, and select what you're looking for and offering!");
    return;
  }

  if (communityCheckboxes.length === 0) {
    alert("Pick at least one community to post!");
    return;
  }

  let selectedCommunities = Array.from(communityCheckboxes).map(cb => cb.value);

  if (selectedCommunities.length === 1 && selectedCommunities[0] === "all") {
    const userRef = doc(db, "users", user.uid);
    const userDoc = await getDoc(userRef);
    selectedCommunities = userDoc.data().communityIds || [];
    const validCommunities = [];
    for (const commId of selectedCommunities) {
      const commRef = doc(db, "communities", commId);
      const commDoc = await getDoc(commRef);
      const commData = commDoc.data();
      if (commData.members.includes(user.uid) && !(commData.bannedUsers || []).includes(user.uid)) {
        validCommunities.push(commId);
      }
    }
    selectedCommunities = validCommunities;
  } else {
    selectedCommunities = selectedCommunities.map(comm => comm === "current" ? communityId : comm);
  }

  if (selectedCommunities.length === 0) {
    alert("No valid communities selected!");
    return;
  }

  const photoUrls = [];
  for (let i = 0; i < Math.min(photos.length, 5); i++) {
    const compressedBlob = await compressImage(photos[i]);
    const photoRef = ref(storage, `posts/${communityId}/${user.uid}/${Date.now()}_${i}`);
    await uploadBytes(photoRef, compressedBlob);
    const url = await getDownloadURL(photoRef);
    photoUrls.push(url);
  }

  const postData = {
    title,
    description,
    photoUrls,
    location: { latitude: parseFloat(lat), longitude: parseFloat(lon), name: location },
    userId: user.uid,
    createdAt: new Date(),
    category,
    lookingFor,  // Now correctly set
    offering     // Now correctly set
  };

  const postPromises = selectedCommunities.map(commId =>
    addDoc(collection(db, "communities", commId, "posts"), postData)
  );
  await Promise.all(postPromises);

  alert(`Post created in ${selectedCommunities.length} community${selectedCommunities.length > 1 ? 'ies' : ''}!`);
  document.getElementById("newPostForm").reset();
  loadYourPosts(user.uid);
  loadPosts(communityId, true);
  carouselIndex = 0;
  loadCarouselPosts(communityId);
}

async function setupCommunitySelection() {
  const user = auth.currentUser;
  const userRef = doc(db, "users", user.uid);
  const userDoc = await getDoc(userRef);
  const communityIds = userDoc.data().communityIds || [];
  
  const container = document.getElementById("communityCheckboxes");
  if (!container) {
    console.error("communityCheckboxes div not found in DOM yet!");
    return;
  }

  container.innerHTML = "";

  const commRef = doc(db, "communities", communityId);
  const commDoc = await getDoc(commRef);
  const currentCommName = commDoc.data().name;
  container.innerHTML += `
    <label for="comm-current">
      <input type="checkbox" id="comm-current" name="communities" value="current" checked> Current (${currentCommName})
    </label>
  `;

  container.innerHTML += `
    <label for="comm-all">
      <input type="checkbox" id="comm-all" name="communities" value="all"> All Communities
    </label>
  `;

  const communityPromises = communityIds
    .filter(id => id !== communityId)
    .map(id => getDoc(doc(db, "communities", id)));
  const communityDocs = await Promise.all(communityPromises);
  
  communityDocs.forEach((doc, index) => {
    if (doc.exists()) {
      const commData = doc.data();
      if (commData.members.includes(user.uid) && !(commData.bannedUsers || []).includes(user.uid)) {
        const checkbox = document.createElement("label");
        checkbox.setAttribute("for", `comm-${index}`);
        checkbox.innerHTML = `
          <input type="checkbox" id="comm-${index}" name="communities" value="${doc.id}"> ${commData.name}
        `;
        container.appendChild(checkbox);
      }
    }
  });

  const allCheckbox = container.querySelector('input[value="all"]');
  allCheckbox.addEventListener("change", (e) => {
    const otherCheckboxes = container.querySelectorAll('input[name="communities"]:not([value="all"])');
    if (e.target.checked) {
      otherCheckboxes.forEach(cb => cb.checked = false);
    }
  });

  const otherCheckboxes = container.querySelectorAll('input[name="communities"]:not([value="all"])');
  otherCheckboxes.forEach(cb => {
    cb.addEventListener("change", () => {
      if (cb.checked) {
        allCheckbox.checked = false;
      }
    });
  });
}

async function deletePost(postId) {
  const user = auth.currentUser;
  const commData = await getCommData();
  const isAdmin = commData.admins?.includes(user.uid) || commData.creatorId === user.uid;
  const postRef = doc(db, "communities", communityId, "posts", postId);
  const postDoc = await getDoc(postRef);
  const postData = postDoc.data();

  if (!isAdmin && postData.userId !== user.uid) {
    alert("You can’t delete this post!");
    return;
  }

  if (confirm("Are you sure you want to delete this post? This will also delete all comments, replies, and photos.")) {
    const loadingDiv = document.createElement("div");
    loadingDiv.className = "loading-overlay";
    loadingDiv.innerHTML = "Deleting...";
    document.body.appendChild(loadingDiv);

    const commentsQ = query(collection(db, "communities", communityId, "posts", postId, "comments"));
    const commentsSnapshot = await getDocs(commentsQ);
    for (const commentDoc of commentsSnapshot.docs) {
      const repliesQ = query(collection(db, "communities", communityId, "posts", postId, "comments", commentDoc.id, "replies"));
      const repliesSnapshot = await getDocs(repliesQ);
      for (const replyDoc of repliesSnapshot.docs) {
        await deleteDoc(doc(db, "communities", communityId, "posts", postId, "comments", commentDoc.id, "replies", replyDoc.id));
      }
      await deleteDoc(doc(db, "communities", communityId, "posts", postId, "comments", commentDoc.id));
    }

    for (const url of postData.photoUrls) {
      const photoRef = ref(storage, url);
      await deleteObject(photoRef).catch(err => console.error("Failed to delete photo:", err));
    }

    await deleteDoc(postRef);
    postCache.delete(postId); // Clear from cache
    loadedPostIds.delete(postId);

    document.body.removeChild(loadingDiv);
    loadYourPosts(user.uid);
    loadPosts(communityId, true); // Reset to refresh
    carouselIndex = 0;
    loadCarouselPosts(communityId);
  }
}

    function setupYourPostsCarousel(postId) {
  const carousel = document.getElementById(`carousel-${postId}-your`);
  const prevBtn = carousel.querySelector(`.carousel-prev[data-post-id="${postId}-your"]`);
  const nextBtn = carousel.querySelector(`.carousel-next[data-post-id="${postId}-your"]`);
  const img = carousel.querySelector(".carousel-image");
  let photoUrls = JSON.parse(carousel.dataset.photos || "[]");

  //console.log(`Setting up YOUR POSTS carousel for post ${postId}:`, { prevBtn, nextBtn, img, photoUrls });

  if (!prevBtn || !nextBtn || !img) {
    console.error(`Your Posts carousel setup failed for post ${postId}: missing elements`);
    return;
  }

  if (photoUrls.length === 0) {
    //console.warn(`No photos for ${postId} in Your Posts, using fallback`);
    photoUrls = ["https://via.placeholder.com/300?text=Photo+1", "https://via.placeholder.com/300?text=Photo+2"];
  }

  img.src = photoUrls[0];
  img.dataset.index = "0";
  let currentIndex = 0;

  prevBtn.removeEventListener("click", prevBtn._carouselHandler);
  nextBtn.removeEventListener("click", nextBtn._carouselHandler);

  prevBtn._carouselHandler = (e) => {
    e.preventDefault();
    e.stopPropagation();
    //console.log(`Prev button clicked for ${postId} in Your Posts by ${auth.currentUser.uid}`);
    currentIndex = (currentIndex - 1 + photoUrls.length) % photoUrls.length;
    img.src = photoUrls[currentIndex];
    img.dataset.index = currentIndex;
    //console.log(`Prev clicked for ${postId} in Your Posts, index: ${currentIndex}, url: ${photoUrls[currentIndex]}`);
  };

  nextBtn._carouselHandler = (e) => {
    e.preventDefault();
    e.stopPropagation();
    //console.log(`Next button clicked for ${postId} in Your Posts by ${auth.currentUser.uid}`);
    currentIndex = (currentIndex + 1) % photoUrls.length;
    img.src = photoUrls[currentIndex];
    img.dataset.index = currentIndex;
    //console.log(`Next clicked for ${postId} in Your Posts, index: ${currentIndex}, url: ${photoUrls[currentIndex]}`);
  };

  prevBtn.addEventListener("click", prevBtn._carouselHandler);
  nextBtn.addEventListener("click", nextBtn._carouselHandler);
  //console.log(`Listeners attached for ${postId} in Your Posts: prevBtn=${!!prevBtn._carouselHandler}, nextBtn=${!!nextBtn._carouselHandler}`);
}

function setupCommunityCarousel(postId) {
  const carousel = document.getElementById(`carousel-${postId}-community`);
  const prevBtn = carousel.querySelector(`.carousel-prev[data-post-id="${postId}-community"]`);
  const nextBtn = carousel.querySelector(`.carousel-next[data-post-id="${postId}-community"]`);
  const img = carousel.querySelector(".carousel-image");
  let photoUrls = JSON.parse(carousel.dataset.photos || "[]");

  //console.log(`Setting up COMMUNITY carousel for post ${postId}:`, { prevBtn, nextBtn, img, photoUrls });

  if (!prevBtn || !nextBtn || !img) {
    console.error(`Community carousel setup failed for post ${postId}: missing elements`);
    return;
  }

  if (photoUrls.length === 0) {
    //console.warn(`No photos for ${postId} in Community, using fallback`);
    photoUrls = ["https://via.placeholder.com/300?text=Photo+1", "https://via.placeholder.com/300?text=Photo+2"];
  }

  img.src = photoUrls[0];
  img.dataset.index = "0";
  let currentIndex = 0;

  prevBtn.removeEventListener("click", prevBtn._carouselHandler);
  nextBtn.removeEventListener("click", nextBtn._carouselHandler);

  prevBtn._carouselHandler = (e) => {
    e.preventDefault();
    e.stopPropagation();
    //console.log(`Prev button clicked for ${postId} in Community by ${auth.currentUser.uid}`);
    currentIndex = (currentIndex - 1 + photoUrls.length) % photoUrls.length;
    img.src = photoUrls[currentIndex];
    img.dataset.index = currentIndex;
    //console.log(`Prev clicked for ${postId} in Community, index: ${currentIndex}, url: ${photoUrls[currentIndex]}`);
  };

  nextBtn._carouselHandler = (e) => {
    e.preventDefault();
    e.stopPropagation();
    //console.log(`Next button clicked for ${postId} in Community by ${auth.currentUser.uid}`);
    currentIndex = (currentIndex + 1) % photoUrls.length;
    img.src = photoUrls[currentIndex];
    img.dataset.index = currentIndex;
    //console.log(`Next clicked for ${postId} in Community, index: ${currentIndex}, url: ${photoUrls[currentIndex]}`);
  };

  prevBtn.addEventListener("click", prevBtn._carouselHandler);
  nextBtn.addEventListener("click", nextBtn._carouselHandler);
  //console.log(`Listeners attached for ${postId} in Community: prevBtn=${!!prevBtn._carouselHandler}, nextBtn=${!!nextBtn._carouselHandler}`);
}

// Add these globals near your other vars (around line 320-ish in your original)
let lastCarouselDoc = null; // Tracks the last doc for pagination
let firstCarouselDoc = null; // For going backwards
let totalCarouselPosts = 0; // Total posts for bounds checking

async function loadCarouselPosts(communityId) {
  const track = document.getElementById("carouselTrack");
  const prevBtn = document.getElementById("carouselPrevBtn");
  const nextBtn = document.getElementById("carouselNextBtn");
  const lookingForFilter = document.getElementById("lookingForFilter")?.value || "";
  const offeringFilter = document.getElementById("offeringFilter")?.value || "";
  const postsPerPage = window.innerWidth < 768 ? 2 : 4; // 2 mobile, 4 desktop

  track.innerHTML = '<div class="loading">Loading...</div>';

  // Get total post count (only once or when filters change)
  if (totalCarouselPosts === 0 || lookingForFilter || offeringFilter) {
    const totalQ = query(
      collection(db, "communities", communityId, "posts"),
      ...(lookingForFilter ? [where("lookingFor", "==", lookingForFilter)] : []),
      ...(offeringFilter ? [where("offering", "==", offeringFilter)] : [])
    );
    const totalSnapshot = await getDocs(totalQ);
    totalCarouselPosts = totalSnapshot.size;
  }

  // Calculate max index
  const maxIndex = Math.ceil(totalCarouselPosts / postsPerPage) - 1;

  // Handle looping
  if (carouselIndex < 0) carouselIndex = maxIndex;
  else if (carouselIndex > maxIndex) carouselIndex = 0;

  let q = query(
    collection(db, "communities", communityId, "posts"),
    ...(lookingForFilter ? [where("lookingFor", "==", lookingForFilter)] : []),
    ...(offeringFilter ? [where("offering", "==", offeringFilter)] : []),
    orderBy("createdAt", "desc"),
    limit(postsPerPage)
  );
  if (carouselIndex > 0 && lastCarouselDoc) q = query(q, startAfter(lastCarouselDoc));

  const snapshot = await getDocs(q);
  const posts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

  if (snapshot.docs.length > 0) {
    lastCarouselDoc = snapshot.docs[snapshot.docs.length - 1];
    firstCarouselDoc = snapshot.docs[0];
  } else if (carouselIndex > 0 && snapshot.empty) {
    carouselIndex = 0;
    return loadCarouselPosts(communityId); // Loop back
  }

  track.innerHTML = posts.length === 0 ? '<p class="no-posts">No posts here, bro!</p>' : "";
  for (const post of posts) {
    const userData = await fetchUserData(post.userId);
    const postDiv = document.createElement("div");
    postDiv.className = "carousel-post";
    postDiv.innerHTML = `
      <h4>${post.title || "Untitled"}</h4>
      <p>Looking For: ${post.lookingFor || "N/A"}</p>
      <p>Offering: ${post.offering || "N/A"}</p>
      <p>By: <span class="username" data-uid="${post.userId}">${userData.name || "Unknown"}</span></p>
      <button class="copy-btn" data-post-id="${post.id}">Copy Post ID</button>
    `;
    track.appendChild(postDiv);
    postDiv.querySelector(".username").addEventListener("click", () => viewProfile(post.userId));
    postDiv.querySelector(".copy-btn").addEventListener("click", (e) => {
      e.stopPropagation();
      copyPostId(post.id);
    });
  }

  prevBtn.disabled = totalCarouselPosts <= postsPerPage || carouselIndex === 0;
  nextBtn.disabled = totalCarouselPosts <= postsPerPage || carouselIndex === maxIndex;
}

function slideCarousel(direction) {
  carouselIndex += direction;
  loadCarouselPosts(communityId);
}

//Helper for scrolldown
// Update infinite scroll to respect the search state
const sentinel = document.getElementById("sentinel");
  const observer = new IntersectionObserver((entries) => {
    if (entries[0].isIntersecting && !isLoading && loadedPostIds.size < totalPosts && !isSearching) {
      isLoading = true;
      loadPosts(communityId).then(() => {
        isLoading = false;
      });
    }
  }, { threshold: 1.0 });

  observer.observe(sentinel);

let lastY = 0;
window.addEventListener("touchmove", debounce(() => {
  const currentY = window.scrollY;
  if (currentY > lastY && currentY + window.innerHeight >= document.body.scrollHeight - 50) {
    if (!isLoading && loadedPostIds.size < totalPosts) {
      isLoading = true;
      loadPosts(communityId).then(() => {
        isLoading = false;
      });
    }
  }
  lastY = currentY;
}, 200));

async function loadPosts(communityId, reset = false) {
  if (isFetching || isSearching) return;
  isFetching = true;

  const postsDiv = document.getElementById("postList");
  const caughtUpDiv = document.getElementById("caughtUpMessage");
  const categoryFilter = document.getElementById("categoryFilter")?.value || "";
  const lookingForFilter = document.getElementById("lookingForFilter")?.value || "";
  const offeringFilter = document.getElementById("offeringFilter")?.value || "";

  if (reset) {
    postsDiv.innerHTML = "";
    caughtUpDiv.style.display = "none";
    loadedPostIds.clear();
    lastPostDoc = null;
    postCache.clear();
  }

  let q = query(
    collection(db, "communities", communityId, "posts"),
    ...(categoryFilter ? [where("category", "==", categoryFilter)] : []),
    ...(lookingForFilter ? [where("lookingFor", "==", lookingForFilter)] : []),
    ...(offeringFilter ? [where("offering", "==", offeringFilter)] : []),
    orderBy("createdAt", "desc"),
    limit(POSTS_PER_LOAD)
  );
  if (lastPostDoc && !reset) q = query(q, startAfter(lastPostDoc));

  try {
    const snapshot = await getDocs(q);
    if (snapshot.empty && !initialPostsLoaded) {
      postsDiv.innerHTML = "<p>No posts match your filters!</p>";
      caughtUpDiv.style.display = "none";
      isFetching = false;
      return;
    }

    lastPostDoc = snapshot.docs[snapshot.docs.length - 1];
    totalPosts = totalPosts || (await getDocs(query(collection(db, "communities", communityId, "posts")))).size;
    initialPostsLoaded = true;

    const newPosts = snapshot.docs.filter(doc => !loadedPostIds.has(doc.id));
    newPosts.forEach(doc => postCache.set(doc.id, { id: doc.id, data: doc.data() }));

    await renderPosts({ docs: newPosts }, postsDiv);

    if (loadedPostIds.size > POSTS_PER_LOAD) {
      const hideBtn = document.createElement("button");
      hideBtn.id = "hidePostsBtn";
      hideBtn.textContent = "See less";
      hideBtn.className = "hide-posts-btn";
      hideBtn.addEventListener("click", async () => {
        postsDiv.innerHTML = '<div class="loading">Loading...</div>';
        await loadPosts(communityId, true);
      });
      postsDiv.appendChild(hideBtn);
    }

    caughtUpDiv.style.display = loadedPostIds.size >= totalPosts ? "block" : "none";
  } catch (error) {
    console.error("Failed to load posts:", error);
    postsDiv.innerHTML += "<p>Oops, something broke! Refresh, bro.</p>";
  } finally {
    isFetching = false;
  }
}

// Helper to render posts (extracted for reuse)
async function renderPosts(snapshot, postsDiv) {
  const commData = await getCommData();
  const isAdmin = commData?.admins?.includes(auth.currentUser.uid) || commData?.creatorId === auth.currentUser.uid;
  
  // Batch fetch all user data at once
  const uids = [...new Set(snapshot.docs.map(doc => doc.data().userId).filter(Boolean))];
  await fetchUserData(uids);

  for (const doc of snapshot.docs) {
    const postId = doc.id;
    if (loadedPostIds.has(postId)) continue;
    loadedPostIds.add(postId);

    const post = postCache.get(postId).data;
    const userData = userDataCache[post.userId];
    const isPostAdmin = commData?.admins?.includes(post.userId) || commData?.creatorId === post.userId;
    const commentsQ = query(collection(db, "communities", communityId, "posts", postId, "comments"), orderBy("createdAt", "desc"));
    const commentsSnapshot = await getDocs(commentsQ);
    const commentCount = commentsSnapshot.size;
    const timestamp = post.createdAt ? new Date(post.createdAt.toDate()).toLocaleString() : "N/A";
    const photoUrls = post.photoUrls || [];
    const photoCount = photoUrls.length;
    const reportStatus = await getPostReportStatus(postId);

    if (reportStatus?.isHidden) {
      loadedPostIds.delete(postId);
      continue;
    }

    const postDiv = document.createElement("div");
    postDiv.className = "post";
    postDiv.id = `post-${postId}`;
    postDiv.innerHTML = `
      <div class="post-header">
        <img src="${userData.profilePhoto || 'https://via.placeholder.com/40'}" class="profile-photo" alt="Profile">
        <h3><span class="username" data-uid="${post.userId}">${userData.name} (${userData.username})</span> ${isPostAdmin ? '<span class="admin-tag">Admin</span>' : ''}</h3>
      </div>
      <h3>${post.title || 'Untitled'}</h3>
      <p>${post.description || ''}</p>
      <div class="photo-carousel" id="carousel-${postId}-community" data-photos='${JSON.stringify(photoUrls)}'>
        ${photoCount > 1 ? `<button class="carousel-prev" data-post-id="${postId}-community"><</button>` : ''}
        <img src="${photoUrls[0] || 'https://via.placeholder.com/300?text=No+Image'}" alt="Post photo" class="carousel-image" data-index="0">
        ${photoCount > 1 ? `<button class="carousel-next" data-post-id="${postId}-community">></button>` : ''}
      </div>
      <p>Location: ${post.location?.name || 'N/A'}</p>
      <p>Category: ${post.category || 'N/A'}</p>
      <p>Looking For: ${post.lookingFor || 'N/A'} | Offering: ${post.offering || 'N/A'}</p>
      <p class="timestamp">${timestamp}</p>
      <p class="post-id">Post ID: ${postId} <button class="copy-btn" data-post-id="${postId}">Copy</button></p>
      <button class="report-btn" id="reportPost-${postId}">Report Post</button>
      ${post.userId === auth.currentUser.uid || isAdmin ? `<button class="delete-btn" id="deletePost-${postId}">Delete Post</button>` : ""}
      ${reportStatus?.isOwner && reportStatus.reportCount === 1 ? `
        <div class="report-warning" id="warning-${postId}">
          This post has 1 report. One more hides it—check summary!
        </div>` : ""}
      ${reportStatus?.isOwner && reportStatus.reportCount >= 2 ? `
        <div class="report-warning" id="warning-${postId}">
          This post has ${reportStatus.reportCount} reports and is hidden. Appeal above!
        </div>` : ""}
      ${isAdmin && reportStatus?.reportCount > 0 ? `
        <div class="admin-report-controls" id="admin-controls-${postId}">
          This post has ${reportStatus.reportCount} report${reportStatus.reportCount > 1 ? 's' : ''}.
          <button class="remove-post-btn" data-post-id="${postId}">Remove Post</button>
          <button class="clear-reports-btn" data-post-id="${postId}">Clear Reports</button>
        </div>` : ""}
      <div class="comments-section">
        <a href="#" class="comment-count" id="toggleComments-${postId}">${commentCount} comments</a>
        <div class="comments-thread" id="comments-${postId}" style="display: none;"></div>
        <form id="commentForm-${postId}" class="comment-form">
          <textarea placeholder="Add a comment..." required></textarea>
          <div id="tagSuggestions-${postId}" class="suggestions hidden"></div>
          <button type="submit">Comment</button>
        </form>
      </div>
    `;

    postsDiv.appendChild(postDiv);

    postDiv.querySelector(`.username[data-uid="${post.userId}"]`)?.addEventListener("click", () => viewProfile(post.userId));
    postDiv.querySelector(`#toggleComments-${postId}`)?.addEventListener("click", (e) => {
      e.preventDefault();
      toggleComments(postId);
    });
    postDiv.querySelector(`#commentForm-${postId}`)?.addEventListener("submit", (e) => {
      e.preventDefault();
      addComment(postId, post.userId);
    });
    postDiv.querySelector(`#deletePost-${postId}`)?.addEventListener("click", () => deletePost(postId));
    postDiv.querySelector(`#reportPost-${postId}`)?.addEventListener("click", () => reportPost(postId));
    postDiv.querySelector(`.copy-btn[data-post-id="${postId}"]`)?.addEventListener("click", (e) => {
      e.stopPropagation();
      copyPostId(postId);
    });
    if (isAdmin) {
      postDiv.querySelector(`.remove-post-btn[data-post-id="${postId}"]`)?.addEventListener("click", () => deletePost(postId));
      postDiv.querySelector(`.clear-reports-btn[data-post-id="${postId}"]`)?.addEventListener("click", () => clearReports(postId));
    }
    const textarea = postDiv.querySelector(`#commentForm-${postId} textarea`);
    if (textarea) {
      if (textarea._debouncedInput) textarea.removeEventListener("input", textarea._debouncedInput);
      textarea._debouncedInput = debounce((e) => showTagSuggestions(e.target, postId), 500);
      textarea.addEventListener("input", textarea._debouncedInput);
    }
    if (photoCount > 1) setupCommunityCarousel(postId);
  }
}

// Infinite scroll listener
function setupInfiniteScroll() {
  const observer = new IntersectionObserver(async (entries) => {
    if (entries[0].isIntersecting && loadedPostIds.size < totalPosts && !isSearching) {
      await loadPosts(communityId);
    }
  }, { threshold: 1.0 });
  observer.observe(document.getElementById("sentinel"));

  window.addEventListener("scroll", debounce(async () => {
    const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
    const scrollPercent = (scrollTop + clientHeight) / scrollHeight;
    if (scrollPercent > 0.7 && !isFetching && loadedPostIds.size < totalPosts && !isSearching) {
      await loadPosts(communityId); // Pre-fetch at 70%
    }
  }, 400));
}

async function loadYourPosts(userId) {
  const yourPostsList = document.getElementById("yourPostsList");
  yourPostsList.innerHTML = ""; // Clear initially
  let lastYourPostDoc = null;
  let firstYourPostDoc = null; // Track the first doc for reset
  let shownPostIds = new Set(); // Track displayed post IDs

  async function fetchYourPosts(reset = false) {
    //console.log("Fetching your posts, reset:", reset, "shownPostIds:", shownPostIds.size);
    const commData = await getCommData();
    const isAdmin = commData.admins?.includes(auth.currentUser.uid) || commData.creatorId === auth.currentUser.uid;
    await fetchUserData(userId); // Cache current user's data

    // Save scroll position
    const scrollTop = window.scrollY || document.documentElement.scrollTop;

    let q = query(
      collection(db, "communities", communityId, "posts"),
      where("userId", "==", userId),
      orderBy("createdAt", "desc"),
      limit(2) // 2 posts per fetch
    );
    if (lastYourPostDoc && !reset) q = query(q, startAfter(lastYourPostDoc));
    else if (reset) firstYourPostDoc = null; // Reset to start

    const snapshot = await getDocs(q);
    if (snapshot.empty && shownPostIds.size === 0) {
      yourPostsList.innerHTML = "<p>No posts yet, bro!</p>";
      await updateButtons(); // Now async
      window.scrollTo(0, scrollTop);
      return;
    }

    if (!firstYourPostDoc) firstYourPostDoc = snapshot.docs[0]; // Set first doc on initial load
    lastYourPostDoc = snapshot.docs[snapshot.docs.length - 1];

    // If reset, clear and show only first 2
    if (reset) {
      yourPostsList.innerHTML = "";
      shownPostIds.clear();
      console.log("Resetting to first 2 posts!");
    }

    for (const doc of snapshot.docs) {
      if (shownPostIds.has(doc.id)) continue; // Skip duplicates
      shownPostIds.add(doc.id);

      const post = doc.data();
      if (!post.userId) {
        console.error(`Post ${doc.id} has no userId! Post data:`, post);
        yourPostsList.innerHTML += `<div class="post-error">Error: Post ${doc.id} is missing user data.</div>`;
        continue;
      }
      const userData = userDataCache[post.userId];
      const isPostAdmin = commData.admins?.includes(post.userId) || commData.creatorId === post.userId;
      const timestamp = new Date(post.createdAt.toDate()).toLocaleString();
      const photoUrls = post.photoUrls || [];
      const photoCount = photoUrls.length;
      const reportStatus = await getPostReportStatus(doc.id);

      const postDiv = document.createElement("div");
      postDiv.className = "post";
      postDiv.id = `post-${doc.id}`;
      postDiv.innerHTML = `
        <div class="post-header">
          <img src="${userData.profilePhoto || 'https://via.placeholder.com/40'}" class="profile-photo" alt="Profile">
          <h3><span class="username" data-uid="${post.userId}">${userData.name} (${userData.username})</span> ${isPostAdmin ? '<span class="admin-tag">Admin</span>' : ''}</h3>
        </div>
        <h3>${post.title}</h3>
        <p>${post.description}</p>
        <div class="photo-carousel" id="carousel-${doc.id}-your" data-photos='${JSON.stringify(photoUrls)}'>
          ${photoCount > 1 ? `<button class="carousel-prev" data-post-id="${doc.id}-your"><</button>` : ''}
          <img src="${photoUrls[0] || 'https://via.placeholder.com/300?text=No+Image'}" alt="Post photo" class="carousel-image" data-index="0">
          ${photoCount > 1 ? `<button class="carousel-next" data-post-id="${doc.id}-your">></button>` : ''}
        </div>
        <p>Location: ${post.location.name}</p>
        <p>Category: ${post.category || 'N/A'} | Looking For: ${post.lookingFor || 'N/A'} | Offering: ${post.offering || 'N/A'}</p>
        <p class="timestamp">${timestamp}</p>
        <p class="post-id">Post ID: ${doc.id} <button class="copy-btn" data-post-id="${doc.id}">Copy</button></p>
        ${post.userId === auth.currentUser.uid || isAdmin ? `<button class="delete-btn" id="deletePost-${doc.id}">Delete Post</button>` : ""}
        ${reportStatus.isOwner && reportStatus.reportCount === 1 ? `
          <div class="report-warning" id="warning-${doc.id}">
            This post has 1 report. One more hides it—check summary!
          </div>` : ""}
        ${reportStatus.isOwner && reportStatus.reportCount >= 2 ? `
          <div class="report-warning" id="warning-${doc.id}">
            This post has ${reportStatus.reportCount} reports and is hidden. Appeal above!
          </div>` : ""}
      `;
      yourPostsList.appendChild(postDiv);

      postDiv.querySelector(`.username[data-uid="${post.userId}"]`).addEventListener("click", () => viewProfile(post.userId));
      const deleteBtn = postDiv.querySelector(`#deletePost-${doc.id}`);
      if (deleteBtn) deleteBtn.addEventListener("click", () => deletePost(doc.id));
      postDiv.querySelector(`.copy-btn[data-post-id="${doc.id}"]`).addEventListener("click", (e) => {
        e.stopPropagation();
        copyPostId(doc.id);
      });
      if (photoCount > 1) setupYourPostsCarousel(doc.id);
    }

    await updateButtons(); // Now async
    window.scrollTo(0, scrollTop); // Restore scroll position
  }

  async function updateButtons() {
    // Remove existing buttons
    const existingMoreBtn = yourPostsList.querySelector("#seeMoreYourPostsBtn");
    const existingLessBtn = yourPostsList.querySelector("#seeLessYourPostsBtn");
    if (existingMoreBtn) existingMoreBtn.remove();
    if (existingLessBtn) existingLessBtn.remove();

    // Create button container
    const buttonContainer = document.createElement("div");
    buttonContainer.id = "yourPostsButtons";
    buttonContainer.style.cssText = "margin-top: 10px; text-align: center; display: block !important; visibility: visible !important;";

    // Create buttons
    const seeMoreBtn = document.createElement("button");
    seeMoreBtn.id = "seeMoreYourPostsBtn";
    seeMoreBtn.textContent = "See More";
    seeMoreBtn.className = "see-more-btn";
    seeMoreBtn.style.cssText = "display: block !important; margin: 5px auto; padding: 5px 10px; visibility: visible !important; opacity: 1 !important; position: relative !important;";
    seeMoreBtn.addEventListener("click", () => fetchYourPosts());

    const seeLessBtn = document.createElement("button");
    seeLessBtn.id = "seeLessYourPostsBtn";
    seeLessBtn.textContent = "See Less";
    seeLessBtn.className = "see-less-btn";
    seeLessBtn.style.cssText = "display: none !important; margin: 5px auto; padding: 5px 10px; visibility: hidden !important; opacity: 0 !important; position: relative !important;";
    seeLessBtn.addEventListener("click", () => fetchYourPosts(true));

    // Append to container
    buttonContainer.appendChild(seeMoreBtn);
    buttonContainer.appendChild(seeLessBtn);
    yourPostsList.appendChild(buttonContainer);

    // Get total posts synchronously
    const totalQ = query(collection(db, "communities", communityId, "posts"), where("userId", "==", userId));
    const totalSnapshot = await getDocs(totalQ);
    const totalPosts = totalSnapshot.size;
    console.log("Total posts:", totalPosts, "Shown posts:", shownPostIds.size);

    // Set button visibility
    if (shownPostIds.size >= totalPosts) {
      seeMoreBtn.style.cssText = "display: none !important; margin: 5px auto; padding: 5px 10px; visibility: hidden !important; opacity: 0 !important;";
      seeLessBtn.style.cssText = "display: block !important; margin: 5px auto; padding: 5px 10px; visibility: visible !important; opacity: 1 !important; position: relative !important;";
    } else {
      seeMoreBtn.style.cssText = "display: block !important; margin: 5px auto; padding: 5px 10px; visibility: visible !important; opacity: 1 !important; position: relative !important;";
      seeLessBtn.style.cssText = shownPostIds.size > 2 
        ? "display: block !important; margin: 5px auto; padding: 5px 10px; visibility: visible !important; opacity: 1 !important; position: relative !important;" 
        : "display: none !important; margin: 5px auto; padding: 5px 10px; visibility: hidden !important; opacity: 0 !important;";
    }

    // Log computed styles
    //console.log("See More - Display:", window.getComputedStyle(seeMoreBtn).display, "Visibility:", window.getComputedStyle(seeMoreBtn).visibility);
    //console.log("See Less - Display:", window.getComputedStyle(seeLessBtn).display, "Visibility:", window.getComputedStyle(seeLessBtn).visibility);
    //console.log("Buttons updated - See More DOM:", !!document.getElementById("seeMoreYourPostsBtn"));
    //console.log("Buttons updated - See Less DOM:", !!document.getElementById("seeLessYourPostsBtn"));
  }

  await fetchYourPosts(); // Initial fetch
}

async function searchPostsById(postId) {
    const postsDiv = document.getElementById("postList");
    const caughtUpDiv = document.getElementById("caughtUpMessage");
    postsDiv.innerHTML = '<div class="loading">Searching...</div>';
    caughtUpDiv.style.display = "none";

    if (!postId || postId.trim() === "") {
      isSearching = false;
      postsDiv.innerHTML = "";
      await loadPosts(communityId, true); // Reset to full list
      return;
    }

    isSearching = true; // Set flag to pause scrolldown

    try {
      const q = query(
        collection(db, "communities", communityId, "posts"),
        where("__name__", "==", postId.trim())
      );
      const snapshot = await getDocs(q);
      postsDiv.innerHTML = "";

      if (snapshot.empty) {
        postsDiv.innerHTML = `<p>No post found with ID: ${postId}</p>`;
        return;
      }

      const doc = snapshot.docs[0];
      const post = doc.data();
      const actualPostId = doc.id;

      const userData = await fetchUserData(post.userId || "unknown");
      const currentUser = auth.currentUser;
      const commData = await getCommData();
      const isAdmin = commData?.admins?.includes(currentUser.uid) || commData?.creatorId === currentUser.uid;
      const isOwner = post.userId === currentUser.uid;

      const reportStatus = await getPostReportStatus(actualPostId);
      if (reportStatus.isHidden) {
        postsDiv.innerHTML = `<p>Post ID ${postId} is hidden due to reports (visible to admins/owner only).</p>`;
        return;
      }

      const commentsQ = query(collection(db, "communities", communityId, "posts", actualPostId, "comments"));
      const commentsSnapshot = await getDocs(commentsQ);
      const commentCount = commentsSnapshot.size;

      const timestamp = post.createdAt ? new Date(post.createdAt.toDate()).toLocaleString() : "N/A";
      const photoUrls = post.photoUrls || [];
      const photoCount = photoUrls.length;

      postsDiv.innerHTML = `
        <div class="post" id="post-${actualPostId}">
          <h3>${post.title || "No Title"}</h3>
          <p>${post.description || "No Description"}</p>
          <div class="photo-carousel" id="carousel-${actualPostId}-search" data-photos='${JSON.stringify(photoUrls)}'>
            ${photoCount > 1 ? `<button class="carousel-prev" data-post-id="${actualPostId}-search"><</button>` : ""}
            <img src="${photoUrls[0] || 'https://via.placeholder.com/300?text=No+Image'}" alt="Post photo" class="carousel-image">
            ${photoCount > 1 ? `<button class="carousel-next" data-post-id="${actualPostId}-search">></button>` : ""}
          </div>
          <p>By: <span class="username" data-uid="${post.userId || 'unknown'}">${userData.name || "Unknown"} (${userData.username || "unknown"})</span></p>
          <p>Location: ${post.location?.name || "N/A"}</p>
          <p>Category: ${post.category || "N/A"}</p>
          <p>Looking For: ${post.lookingFor || "N/A"} | Offering: ${post.offering || "N/A"}</p>
          <p>Posted: ${timestamp}</p>
          <p>Post ID: ${actualPostId} <button class="copy-btn" data-post-id="${actualPostId}">Copy</button></p>
          <button class="report-btn" id="reportPost-${actualPostId}">Report Post</button>
          ${(isOwner || isAdmin) ? `<button class="delete-btn" id="deletePost-${actualPostId}">Delete Post</button>` : ""}
          ${reportStatus.isOwner && reportStatus.reportCount === 1 ? `
            <div class="report-warning" id="warning-${actualPostId}">
              This post has 1 report. One more will hide it from others—check it in the summary above!
            </div>` : ""}
          ${reportStatus.isOwner && reportStatus.reportCount >= 2 ? `
            <div class="report-warning" id="warning-${actualPostId}">
              This post has ${reportStatus.reportCount} reports and is hidden from others. Appeal in the summary above!
            </div>` : ""}
          ${isAdmin && reportStatus.reportCount > 0 ? `
            <div class="admin-report-controls" id="admin-controls-${actualPostId}">
              This post received ${reportStatus.reportCount} report${reportStatus.reportCount > 1 ? 's' : ''}.
              <button class="remove-post-btn" data-post-id="${actualPostId}">Remove Post</button>
              <button class="clear-reports-btn" data-post-id="${actualPostId}">Clear Reports</button>
            </div>` : ""}
          <div class="comments-section">
            <a href="#" class="comment-count" id="toggleComments-${actualPostId}">${commentCount} comments</a>
            <div class="comments-thread" id="comments-${actualPostId}" style="display: none;"></div>
            <form id="commentForm-${actualPostId}" class="comment-form">
              <textarea placeholder="Add a comment..." required></textarea>
              <button type="submit">Comment</button>
            </form>
          </div>
        </div>
      `;

      const postDiv = postsDiv.querySelector(`#post-${actualPostId}`);
      postDiv.querySelector(`.username[data-uid="${post.userId || 'unknown'}"]`).addEventListener("click", () => viewProfile(post.userId || "unknown"));
      postDiv.querySelector(`.copy-btn[data-post-id="${actualPostId}"]`).addEventListener("click", (e) => {
        e.stopPropagation();
        copyPostId(actualPostId);
      });
      postDiv.querySelector(`#reportPost-${actualPostId}`).addEventListener("click", () => reportPost(actualPostId));
      const deleteBtn = postDiv.querySelector(`#deletePost-${actualPostId}`);
      if (deleteBtn) deleteBtn.addEventListener("click", () => deletePost(actualPostId));
      if (isAdmin) {
        postDiv.querySelector(`.remove-post-btn[data-post-id="${actualPostId}"]`)?.addEventListener("click", () => deletePost(actualPostId));
        postDiv.querySelector(`.clear-reports-btn[data-post-id="${actualPostId}"]`)?.addEventListener("click", () => clearReports(actualPostId));
      }
      postDiv.querySelector(`#toggleComments-${actualPostId}`).addEventListener("click", (e) => {
        e.preventDefault();
        toggleComments(actualPostId);
      });
      postDiv.querySelector(`#commentForm-${actualPostId}`).addEventListener("submit", (e) => {
        e.preventDefault();
        addComment(actualPostId, post.userId);
      });
      if (photoCount > 1) setupSearchCarousel(actualPostId);

    } catch (error) {
      console.error("Search error:", error);
      postsDiv.innerHTML = "<p>Something went wrong, try again!</p>";
    }
  }

// Define the scroll handler globally so we can remove it later
const scrollHandler = debounce(async () => {
    if (isLoading || loadedPostIds.size >= totalPosts || isSearching) return;

    const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
    if (scrollTop + clientHeight >= scrollHeight - 50) {
      isLoading = true;
      await loadPosts(communityId);
      isLoading = false;
    }
  }, 500);

  window.addEventListener("scroll", scrollHandler);

// Keep this helper as is—it’s solid for the carousel
function setupSearchCarousel(postId) {
  const carousel = document.getElementById(`carousel-${postId}-search`);
  const prevBtn = carousel.querySelector(`.carousel-prev[data-post-id="${postId}-search"]`);
  const nextBtn = carousel.querySelector(`.carousel-next[data-post-id="${postId}-search"]`);
  const img = carousel.querySelector(".carousel-image");
  let photoUrls = JSON.parse(carousel.dataset.photos || "[]");
  let currentIndex = 0;

  if (!prevBtn || !nextBtn || !img) return;

  if (photoUrls.length === 0) {
    photoUrls = ["https://via.placeholder.com/300?text=No+Image"];
  }

  img.src = photoUrls[0];

  prevBtn.addEventListener("click", (e) => {
    e.preventDefault();
    currentIndex = (currentIndex - 1 + photoUrls.length) % photoUrls.length;
    img.src = photoUrls[currentIndex];
  });

  nextBtn.addEventListener("click", (e) => {
    e.preventDefault();
    currentIndex = (currentIndex + 1) % photoUrls.length;
    img.src = photoUrls[currentIndex];
  });
}

    async function showTagSuggestions(textarea, postId) {
      const text = textarea.value;
      const match = text.match(/@(\w*)$/);
      const suggestionsDiv = document.getElementById(`tagSuggestions-${postId}`);

      suggestionsDiv.innerHTML = "";
      suggestionsDiv.classList.add("hidden");

      if (match && match[1].length > 0) {
        const prefix = match[1].toLowerCase();
        const commData = await getCommData();
        const members = commData.members || [];
        const batches = [];
        for (let i = 0; i < members.length; i += 10) {
          batches.push(members.slice(i, i + 10));
        }

        const userPromises = batches.map(batch => {
          const q = query(collection(db, "users"), where("__name__", "in", batch));
          return getDocs(q);
        });
        const snapshots = await Promise.all(userPromises);
        const allUsers = snapshots.flatMap(snapshot => snapshot.docs.map(doc => doc.data()));

        const filteredUsers = allUsers
          .filter(user => user.username.toLowerCase().startsWith(prefix))
          .slice(0, 5);

        if (filteredUsers.length > 0) {
          suggestionsDiv.style.position = "absolute";
          suggestionsDiv.style.left = `${textarea.offsetLeft}px`;
          suggestionsDiv.style.top = `${textarea.offsetTop + textarea.offsetHeight}px`;
          suggestionsDiv.classList.remove("hidden");

          filteredUsers.forEach(user => {
            const suggestion = document.createElement("div");
            suggestion.classList.add("suggestion-item");
            suggestion.textContent = `@${user.username}`;
            suggestion.addEventListener("click", () => {
              textarea.value = text.replace(/@\w*$/, `@${user.username} `);
              suggestionsDiv.classList.add("hidden");
            });
            suggestionsDiv.appendChild(suggestion);
          });
        }
      }
    }

    document.addEventListener("click", (e) => {
  const allTagSuggestionDivs = document.querySelectorAll("[id^='tagSuggestions-']"); // Only target tag-related IDs
  allTagSuggestionDivs.forEach(div => {
    const textarea = div.previousElementSibling;
    if (!div.contains(e.target) && (!textarea || !textarea.contains(e.target))) {
      div.classList.add("hidden");
    }
  });
  // Explicitly prevent hiding postLocationSuggestions here
  const postLocationSuggestions = document.getElementById("postLocationSuggestions");
  if (postLocationSuggestions && !postLocationSuggestions.contains(e.target) && !document.getElementById("postLocation").contains(e.target)) {
    postLocationSuggestions.classList.add("hidden");
  }
});

async function getUserByUsername(username) {
  if (userDataCache[`username:${username}`]) {
    return userDataCache[`username:${username}`];
  }

  // Fallback to Firestore query if not cached
  const q = query(collection(db, "users"), where("username", "==", username), limit(1));
  const snapshot = await getDocs(q);
  if (snapshot.empty) return null;
  const userData = snapshot.docs[0].data();
  const uid = snapshot.docs[0].id;
  return await fetchUserData(uid); // This caches it too
}

async function processMentions(text) {
  const mentionRegex = /@(\w+)/g;
  let processedText = text;
  const matches = [...text.matchAll(mentionRegex)];

  for (const match of matches) {
    const username = match[1];
    const user = await getUserByUsername(username);
    if (user) {
      processedText = processedText.replace(
        `@${username}`,
        `<a href="#" class="mention" data-uid="${user.uid}">@${username}</a>`
      );
    }
  }
  return processedText;
}

async function toggleComments(postId) {
  const commentsDiv = document.getElementById(`comments-${postId}`);
  const toggleLink = document.getElementById(`toggleComments-${postId}`);
  const commData = await getCommData();
  const isAdmin = commData.admins?.includes(auth.currentUser.uid) || commData.creatorId === auth.currentUser.uid;

  if (!commentsDiv.dataset.loaded) {
    commentsDiv.style.display = "block";
    toggleLink.textContent = "Hide comments";
    commentsDiv.innerHTML = '<div class="loading">Loading...</div>';

    const q = query(
      collection(db, "communities", communityId, "posts", postId, "comments"),
      orderBy("createdAt", "desc"),
      limit(itemsPerPage)
    );
    const snapshot = await getDocs(q);
    commentsDiv.innerHTML = "";

    let lastCommentDoc = snapshot.docs[snapshot.docs.length - 1];
    const totalCommentsCount = await totalComments(postId);

    for (const doc of snapshot.docs) {
      await renderComment(doc, commentsDiv, postId, isAdmin);
    }

    if (commentsDiv.children.length < totalCommentsCount) {
      const seeMoreBtn = document.createElement("button");
      seeMoreBtn.textContent = "See more comments";
      seeMoreBtn.className = "see-more-btn";
      seeMoreBtn.dataset.postId = postId;
      seeMoreBtn.dataset.lastDocId = lastCommentDoc ? lastCommentDoc.id : "";
      seeMoreBtn.addEventListener("click", loadMoreComments);
      commentsDiv.appendChild(seeMoreBtn);
    }

    commentsDiv.dataset.loaded = "true";
    commentsDiv.dataset.totalComments = totalCommentsCount;
    toggleLink.textContent = `${totalCommentsCount} comments`;
  } else if (commentsDiv.style.display === "none") {
    commentsDiv.style.display = "block";
    toggleLink.textContent = "Hide comments";
  } else {
    commentsDiv.style.display = "none";
    toggleLink.textContent = `${commentsDiv.dataset.totalComments || await totalComments(postId)} comments`;
  }
}

async function loadMoreComments(event) {
  const seeMoreBtn = event.target;
  const postId = seeMoreBtn.dataset.postId;
  const lastDocId = seeMoreBtn.dataset.lastDocId;
  const commentsDiv = document.getElementById(`comments-${postId}`);
  const commData = await getCommData();
  const isAdmin = commData.admins?.includes(auth.currentUser.uid) || commData.creatorId === auth.currentUser.uid;

  seeMoreBtn.textContent = "Loading...";
  seeMoreBtn.disabled = true;

  // Fetch the last doc we loaded
  let lastDoc = null;
  if (lastDocId) {
    lastDoc = await getDoc(doc(db, "communities", communityId, "posts", postId, "comments", lastDocId));
  }

  const q = query(
    collection(db, "communities", communityId, "posts", postId, "comments"),
    orderBy("createdAt", "desc"),
    startAfter(lastDoc),
    limit(itemsPerPage)
  );
  const snapshot = await getDocs(q);

  // Remove the old button
  seeMoreBtn.remove();

  // Append new comments
  for (const doc of snapshot.docs) {
    await renderComment(doc, commentsDiv, postId, isAdmin);
  }

  // Update last doc and check if more remain
  const lastCommentDoc = snapshot.docs[snapshot.docs.length - 1];
  const totalCommentsCount = parseInt(commentsDiv.dataset.totalComments, 10);
  if (commentsDiv.children.length < totalCommentsCount) {
    const newSeeMoreBtn = document.createElement("button");
    newSeeMoreBtn.textContent = "See more comments";
    newSeeMoreBtn.className = "see-more-btn";
    newSeeMoreBtn.dataset.postId = postId;
    newSeeMoreBtn.dataset.lastDocId = lastCommentDoc ? lastCommentDoc.id : "";
    newSeeMoreBtn.addEventListener("click", loadMoreComments);
    commentsDiv.appendChild(newSeeMoreBtn);
  }

  // Update toggle link count (just in case)
  document.getElementById(`toggleComments-${postId}`).textContent = `${totalCommentsCount} comments`;
}

    async function renderComment(doc, commentsDiv, postId, isAdmin) {
  const comment = doc.data();
  const userData = await fetchUserData(comment.userId);
  const commData = await getCommData();
  const isCommentAdmin = commData.admins?.includes(comment.userId) || commData.creatorId === comment.userId;

  // Process @mentions into clickable links
  const commentText = await processMentions(comment.text);

  const timestamp = new Date(comment.createdAt.toDate()).toLocaleString();
  const repliesQ = query(collection(db, "communities", communityId, "posts", postId, "comments", doc.id, "replies"), orderBy("createdAt", "desc"));
  const repliesSnapshot = await getDocs(repliesQ);
  const replyCount = repliesSnapshot.size;

  const commentDiv = document.createElement("div");
  commentDiv.className = "comment-bubble";
  commentDiv.innerHTML = `
    <div class="comment-content">
      <img src="${userData.profilePhoto || 'https://via.placeholder.com/30'}" class="profile-photo" alt="Profile">
      <div class="comment-text">
        <span class="username" data-uid="${comment.userId}">${userData.name}</span> ${isCommentAdmin ? '<span class="admin-tag">Admin</span>' : ''}
        <p>${commentText}</p>
        <span class="timestamp">${timestamp}</span>
        <div class="comment-actions">
          ${replyCount > 0 ? `<a href="#" class="reply-count" id="toggleReplies-${doc.id}">View ${replyCount} replies</a>` : ""}
          <button class="reply-btn" id="replyBtn-${doc.id}">Reply</button>
          ${isAdmin || comment.userId === auth.currentUser.uid ? `<button class="delete-comment-btn" id="deleteComment-${doc.id}">Delete</button>` : ""}
        </div>
      </div>
    </div>
    <div class="replies-thread" id="replies-${doc.id}" style="display: none;"></div>
    <form id="replyForm-${doc.id}" class="reply-form hidden">
      <div class="replying-to">Replying to ${userData.name}'s comment <button type="button" class="cancel-reply">Cancel</button></div>
      <textarea placeholder="Your reply..." required></textarea>
      <div id="tagSuggestions-${doc.id}-${doc.id}" class="suggestions hidden"></div>
      <button type="submit">Reply</button>
    </form>
  `;
  commentsDiv.appendChild(commentDiv);

  // Add click listeners to all username elements (including mentions)
  commentDiv.querySelectorAll(`.username`).forEach(el => {
    const uid = el.dataset.uid;
    el.addEventListener("click", () => viewProfile(uid));
  });
  commentDiv.querySelectorAll(`.mention`).forEach(el => {
    const uid = el.dataset.uid;
    el.addEventListener("click", (e) => {
      e.preventDefault(); // Prevent the default <a> behavior
      viewProfile(uid);
    });
  });

  const replyBtn = commentDiv.querySelector(`#replyBtn-${doc.id}`);
  replyBtn.addEventListener("click", () => {
    const replyForm = commentDiv.querySelector(`#replyForm-${doc.id}`);
    replyForm.classList.toggle("hidden");
    if (!replyForm.classList.contains("hidden")) replyForm.querySelector("textarea").focus();
  });
  commentDiv.querySelector(`#replyForm-${doc.id}`).addEventListener("submit", (e) => {
    e.preventDefault();
    addReply(postId, doc.id, comment.userId);
  });
  commentDiv.querySelector(`.cancel-reply`).addEventListener("click", () => {
    commentDiv.querySelector(`#replyForm-${doc.id}`).classList.add("hidden");
  });
  const toggleReplies = commentDiv.querySelector(`#toggleReplies-${doc.id}`);
  if (toggleReplies) {
    toggleReplies.addEventListener("click", (e) => {
      e.preventDefault();
      toggleRepliesFn(postId, doc.id);
    });
  }
  const deleteBtn = commentDiv.querySelector(`#deleteComment-${doc.id}`);
  if (deleteBtn) {
    deleteBtn.addEventListener("click", () => deleteComment(postId, doc.id));
  }
}

async function toggleRepliesFn(postId, commentId) {
  const repliesDiv = document.getElementById(`replies-${commentId}`);
  const toggleLink = document.getElementById(`toggleReplies-${commentId}`);
  const commData = await getCommData();
  const isAdmin = commData.admins?.includes(auth.currentUser.uid) || commData.creatorId === auth.currentUser.uid;

  // If repliesDiv hasn’t been loaded yet (first toggle), fetch initial batch
  if (!repliesDiv.dataset.loaded) {
    repliesDiv.style.display = "block";
    toggleLink.textContent = "Hide replies";
    repliesDiv.innerHTML = '<div class="loading">Loading...</div>';

    const q = query(
      collection(db, "communities", communityId, "posts", postId, "comments", commentId, "replies"),
      orderBy("createdAt", "desc"),
      limit(itemsPerPage)
    );
    const snapshot = await getDocs(q);
    repliesDiv.innerHTML = ""; // Clear loading

    let lastReplyDoc = snapshot.docs[snapshot.docs.length - 1];
    const totalRepliesCount = await totalReplies(postId, commentId);

    for (const doc of snapshot.docs) {
      await renderReply(doc, repliesDiv, postId, commentId, isAdmin);
    }

    // Add "See more" button if there’s more to load
    if (repliesDiv.children.length < totalRepliesCount) {
      const seeMoreBtn = document.createElement("button");
      seeMoreBtn.textContent = "See more replies";
      seeMoreBtn.className = "see-more-btn";
      seeMoreBtn.dataset.postId = postId;
      seeMoreBtn.dataset.commentId = commentId; // Store commentId for replies
      seeMoreBtn.dataset.lastDocId = lastReplyDoc ? lastReplyDoc.id : ""; // Store last doc ID
      seeMoreBtn.addEventListener("click", loadMoreReplies);
      repliesDiv.appendChild(seeMoreBtn);
    }

    // Mark as loaded and store total count
    repliesDiv.dataset.loaded = "true";
    repliesDiv.dataset.totalReplies = totalRepliesCount;
    toggleLink.textContent = `View ${totalRepliesCount} replies`;
  } 
  // Toggle visibility if already loaded
  else if (repliesDiv.style.display === "none") {
    repliesDiv.style.display = "block";
    toggleLink.textContent = "Hide replies";
  } else {
    repliesDiv.style.display = "none";
    toggleLink.textContent = `View ${repliesDiv.dataset.totalReplies || await totalReplies(postId, commentId)} replies`;
  }
}

async function loadMoreReplies(event) {
  const seeMoreBtn = event.target;
  const postId = seeMoreBtn.dataset.postId;
  const commentId = seeMoreBtn.dataset.commentId;
  const lastDocId = seeMoreBtn.dataset.lastDocId;
  const repliesDiv = document.getElementById(`replies-${commentId}`);
  const commData = await getCommData();
  const isAdmin = commData.admins?.includes(auth.currentUser.uid) || commData.creatorId === auth.currentUser.uid;

  seeMoreBtn.textContent = "Loading...";
  seeMoreBtn.disabled = true;

  // Fetch the last doc we loaded
  let lastDoc = null;
  if (lastDocId) {
    lastDoc = await getDoc(doc(db, "communities", communityId, "posts", postId, "comments", commentId, "replies", lastDocId));
  }

  const q = query(
    collection(db, "communities", communityId, "posts", postId, "comments", commentId, "replies"),
    orderBy("createdAt", "desc"),
    startAfter(lastDoc),
    limit(itemsPerPage)
  );
  const snapshot = await getDocs(q);

  // Remove the old button
  seeMoreBtn.remove();

  // Append new replies
  for (const doc of snapshot.docs) {
    await renderReply(doc, repliesDiv, postId, commentId, isAdmin);
  }

  // Update last doc and check if more remain
  const lastReplyDoc = snapshot.docs[snapshot.docs.length - 1];
  const totalRepliesCount = parseInt(repliesDiv.dataset.totalReplies, 10);
  if (repliesDiv.children.length < totalRepliesCount) {
    const newSeeMoreBtn = document.createElement("button");
    newSeeMoreBtn.textContent = "See more replies";
    newSeeMoreBtn.className = "see-more-btn";
    newSeeMoreBtn.dataset.postId = postId;
    newSeeMoreBtn.dataset.commentId = commentId;
    newSeeMoreBtn.dataset.lastDocId = lastReplyDoc ? lastReplyDoc.id : "";
    newSeeMoreBtn.addEventListener("click", loadMoreReplies);
    repliesDiv.appendChild(newSeeMoreBtn);
  }

  // Update toggle link count (just in case)
  const toggleLink = document.getElementById(`toggleReplies-${commentId}`);
  if (toggleLink) toggleLink.textContent = `View ${totalRepliesCount} replies`;
}

    async function renderReply(doc, repliesDiv, postId, commentId, isAdmin) {
  const reply = doc.data();
  const userData = await fetchUserData(reply.userId);
  const commData = await getCommData();
  const isReplyAdmin = commData.admins?.includes(reply.userId) || commData.creatorId === reply.userId;

  // Process @mentions into clickable links
  const replyText = await processMentions(reply.text);

  const timestamp = new Date(reply.createdAt.toDate()).toLocaleString();

  const replyDiv = document.createElement("div");
  replyDiv.className = "reply-bubble";
  replyDiv.innerHTML = `
    <img src="${userData.profilePhoto || 'https://via.placeholder.com/25'}" class="profile-photo" alt="Profile">
    <div class="reply-text">
      <span class="username" data-uid="${reply.userId}">${userData.name}</span> ${isReplyAdmin ? '<span class="admin-tag">Admin</span>' : ''}
      <p>${replyText}</p>
      <span class="timestamp">${timestamp}</span>
      ${isAdmin || reply.userId === auth.currentUser.uid ? `<button class="delete-reply-btn" id="deleteReply-${doc.id}">Delete</button>` : ""}
    </div>
  `;
  repliesDiv.appendChild(replyDiv);

  // Add click listeners to all username elements (including mentions)
  replyDiv.querySelectorAll(`.username`).forEach(el => {
    const uid = el.dataset.uid;
    el.addEventListener("click", () => viewProfile(uid));
  });
  replyDiv.querySelectorAll(`.mention`).forEach(el => {
    const uid = el.dataset.uid;
    el.addEventListener("click", (e) => {
      e.preventDefault(); // Prevent the default <a> behavior
      viewProfile(uid);
    });
  });

  const deleteBtn = replyDiv.querySelector(`#deleteReply-${doc.id}`);
  if (deleteBtn) {
    deleteBtn.addEventListener("click", () => deleteReply(postId, commentId, doc.id));
  }
}

    async function deleteComment(postId, commentId) {
      const user = auth.currentUser;
      const commData = await getCommData();
      const isAdmin = commData.admins?.includes(user.uid) || commData.creatorId === user.uid;
      const commentRef = doc(db, "communities", communityId, "posts", postId, "comments", commentId);
      const commentDoc = await getDoc(commentRef);
      const commentData = commentDoc.data();

      if (!isAdmin && commentData.userId !== user.uid) {
        alert("You can’t delete this comment!");
        return;
      }

      if (confirm("Are you sure you want to delete this comment?")) {
        await deleteDoc(commentRef);
        toggleComments(postId);
      }
    }

    async function deleteReply(postId, commentId, replyId) {
      const user = auth.currentUser;
      const commData = await getCommData();
      const isAdmin = commData.admins?.includes(user.uid) || commData.creatorId === user.uid;
      const replyRef = doc(db, "communities", communityId, "posts", postId, "comments", commentId, "replies", replyId);
      const replyDoc = await getDoc(replyRef);
      const replyData = replyDoc.data();

      if (!isAdmin && replyData.userId !== user.uid) {
        alert("You can’t delete this reply!");
        return;
      }

      if (confirm("Are you sure you want to delete this reply?")) {
        await deleteDoc(replyRef);
        toggleRepliesFn(postId, commentId);
      }
    }

    async function addComment(postId, postOwnerId) {
  const user = auth.currentUser;
  const text = document.getElementById(`commentForm-${postId}`).querySelector("textarea").value.trim();
  if (!text) return;

  const commentsDiv = document.getElementById(`comments-${postId}`);
  const toggleLink = document.getElementById(`toggleComments-${postId}`);
  const commData = await getCommData();
  const isAdmin = commData.admins?.includes(user.uid) || commData.creatorId === user.uid;

  // Add to Firebase
  const commentDoc = await addDoc(collection(db, "communities", communityId, "posts", postId, "comments"), {
    text,
    userId: user.uid,
    createdAt: new Date()
  });

  // Instant UI update
  const userData = await fetchCurrentUserData();
  const isCommentAdmin = commData.admins?.includes(user.uid) || commData.creatorId === user.uid;
  const commentText = await processMentions(text);
  const timestamp = new Date().toLocaleString();
  const newCommentDiv = document.createElement("div");
  newCommentDiv.className = "comment-bubble";
  newCommentDiv.innerHTML = `
    <div class="comment-content">
      <img src="${userData.profilePhoto || 'https://via.placeholder.com/30'}" class="profile-photo" alt="Profile">
      <div class="comment-text">
        <span class="username" data-uid="${user.uid}">${userData.name}</span> ${isCommentAdmin ? '<span class="admin-tag">Admin</span>' : ''}
        <p>${commentText}</p>
        <span class="timestamp">${timestamp}</span>
        <div class="comment-actions">
          <button class="reply-btn" id="replyBtn-${commentDoc.id}">Reply</button>
          ${isAdmin || user.uid === user.uid ? `<button class="delete-comment-btn" id="deleteComment-${commentDoc.id}">Delete</button>` : ""}
        </div>
      </div>
    </div>
    <div class="replies-thread" id="replies-${commentDoc.id}" style="display: none;"></div>
    <form id="replyForm-${commentDoc.id}" class="reply-form hidden">
      <div class="replying-to">Replying to ${userData.name}'s comment <button type="button" class="cancel-reply">Cancel</button></div>
      <textarea placeholder="Your reply..." required></textarea>
      <div id="tagSuggestions-${commentDoc.id}-${commentDoc.id}" class="suggestions hidden"></div>
      <button type="submit">Reply</button>
    </form>
  `;

  // If comments are visible, prepend the new comment
  if (commentsDiv.style.display !== "none") {
    commentsDiv.insertBefore(newCommentDiv, commentsDiv.firstChild);
  } else {
    commentsDiv.style.display = "block";
    commentsDiv.innerHTML = "";
    commentsDiv.appendChild(newCommentDiv);
    toggleLink.textContent = "Hide comments";
  }

  // Add event listeners
  newCommentDiv.querySelectorAll(".username").forEach(el => {
    el.addEventListener("click", () => viewProfile(user.uid));
  });
  newCommentDiv.querySelectorAll(".mention").forEach(el => {
    const uid = el.dataset.uid;
    el.addEventListener("click", (e) => {
      e.preventDefault();
      viewProfile(uid);
    });
  });
  const replyBtn = newCommentDiv.querySelector(`#replyBtn-${commentDoc.id}`);
  replyBtn.addEventListener("click", () => {
    const replyForm = newCommentDiv.querySelector(`#replyForm-${commentDoc.id}`);
    replyForm.classList.toggle("hidden");
    if (!replyForm.classList.contains("hidden")) replyForm.querySelector("textarea").focus();
  });
  newCommentDiv.querySelector(`#replyForm-${commentDoc.id}`).addEventListener("submit", (e) => {
    e.preventDefault();
    addReply(postId, commentDoc.id, user.uid);
  });
  newCommentDiv.querySelector(".cancel-reply").addEventListener("click", () => {
    newCommentDiv.querySelector(`#replyForm-${commentDoc.id}`).classList.add("hidden");
  });
  const deleteBtn = newCommentDiv.querySelector(`#deleteComment-${commentDoc.id}`);
  if (deleteBtn) deleteBtn.addEventListener("click", () => deleteComment(postId, commentDoc.id));

  // Update comment count
  const commentCount = (await totalComments(postId));
  commentsDiv.dataset.totalComments = commentCount; // Update the stored count
  toggleLink.textContent = `${commentCount} comments`;

  // Send notification if not the post owner
  if (user.uid !== postOwnerId) {
    const commenterData = await fetchCurrentUserData();
    await addDoc(collection(db, "notifications"), {
      userId: postOwnerId,
      type: "comment",
      message: `${commenterData.name || "Someone"} commented on your post: "${text.substring(0, 50)}..."`,
      postId,
      communityId,
      commentId: commentDoc.id,
      timestamp: new Date(),
      seen: false
    });
    updateNotificationBadge(postOwnerId);
  }

  document.getElementById(`commentForm-${postId}`).reset();
}

async function addReply(postId, commentId, commentOwnerId) {
  const user = auth.currentUser;
  const text = document.getElementById(`replyForm-${commentId}`).querySelector("textarea").value.trim();
  if (!text) return;

  const repliesDiv = document.getElementById(`replies-${commentId}`);
  const toggleLink = document.getElementById(`toggleReplies-${commentId}`);
  const commData = await getCommData();
  const isAdmin = commData.admins?.includes(user.uid) || commData.creatorId === user.uid;

  // Add to Firebase
  const replyDoc = await addDoc(collection(db, "communities", communityId, "posts", postId, "comments", commentId, "replies"), {
    text,
    userId: user.uid,
    createdAt: new Date()
  });

  // Instant UI update
  const userData = await fetchCurrentUserData();
  const isReplyAdmin = commData.admins?.includes(user.uid) || commData.creatorId === user.uid;
  const replyText = await processMentions(text);
  const timestamp = new Date().toLocaleString();
  const newReplyDiv = document.createElement("div");
  newReplyDiv.className = "reply-bubble";
  newReplyDiv.innerHTML = `
    <img src="${userData.profilePhoto || 'https://via.placeholder.com/25'}" class="profile-photo" alt="Profile">
    <div class="reply-text">
      <span class="username" data-uid="${user.uid}">${userData.name}</span> ${isReplyAdmin ? '<span class="admin-tag">Admin</span>' : ''}
      <p>${replyText}</p>
      <span class="timestamp">${timestamp}</span>
      ${isAdmin || user.uid === user.uid ? `<button class="delete-reply-btn" id="deleteReply-${replyDoc.id}">Delete</button>` : ""}
    </div>
  `;

  // If replies are visible, prepend the new reply
  if (repliesDiv.style.display !== "none") {
    repliesDiv.insertBefore(newReplyDiv, repliesDiv.firstChild);
  } else {
    repliesDiv.style.display = "block";
    repliesDiv.innerHTML = "";
    repliesDiv.appendChild(newReplyDiv);
    toggleLink.textContent = "Hide replies";
  }

  // Add event listeners
  newReplyDiv.querySelectorAll(".username").forEach(el => {
    el.addEventListener("click", () => viewProfile(user.uid));
  });
  newReplyDiv.querySelectorAll(".mention").forEach(el => {
    const uid = el.dataset.uid;
    el.addEventListener("click", (e) => {
      e.preventDefault();
      viewProfile(uid);
    });
  });
  const deleteBtn = newReplyDiv.querySelector(`#deleteReply-${replyDoc.id}`);
  if (deleteBtn) deleteBtn.addEventListener("click", () => deleteReply(postId, commentId, replyDoc.id));

  // Update reply count
  const replyCount = await totalReplies(postId, commentId);
  repliesDiv.dataset.totalReplies = replyCount; // Update the stored count
  if (toggleLink) toggleLink.textContent = `View ${replyCount} replies`;

  // Send notification if not the comment owner
  if (user.uid !== commentOwnerId) {
    const replierData = await fetchCurrentUserData();
    await addDoc(collection(db, "notifications"), {
      userId: commentOwnerId,
      type: "reply",
      message: `${replierData.name || "Someone"} replied to your comment: "${text.substring(0, 50)}..."`,
      postId,
      communityId,
      commentId,
      replyId: replyDoc.id,
      timestamp: new Date(),
      seen: false
    });
    updateNotificationBadge(commentOwnerId);
  }

  document.getElementById(`replyForm-${commentId}`).reset();
  document.getElementById(`replyForm-${commentId}`).classList.add("hidden");
}

    async function viewProfile(uid) {
  const modal = document.getElementById("viewProfileModal");
  const nameEl = document.getElementById("profileName");
  const photoEl = document.getElementById("profilePhoto");
  const detailsEl = document.getElementById("profileDetails");
  const actionsEl = document.getElementById("profileActions");

  // Loading state
  actionsEl.innerHTML = '<div class="loading">Loading...</div>';
  detailsEl.innerHTML = '';
  nameEl.textContent = '';
  photoEl.src = "https://via.placeholder.com/40";
  document.querySelectorAll(".modal:not(#viewProfileModal)").forEach(m => m.style.display = "none");
  modal.style.display = "flex";
  modal.classList.remove("hidden");

  const userData = await fetchUserData(uid);
  const commData = await getCommData();
  const isCreator = commData.creatorId === auth.currentUser.uid;
  const isAdmin = commData.admins?.includes(auth.currentUser.uid);
  const isSelf = uid === auth.currentUser.uid;
  const isProfileAdmin = commData.admins?.includes(uid) || commData.creatorId === uid;

  const requestQ = query(
    collection(db, "profileRequests"),
    where("requesterId", "==", auth.currentUser.uid),
    where("targetId", "==", uid)
  );
  const requestSnapshot = await getDocs(requestQ);
  const request = requestSnapshot.docs[0]?.data();
  const requestId = requestSnapshot.docs[0]?.id;

  nameEl.textContent = userData.name;
  photoEl.src = userData.profilePhoto || "https://via.placeholder.com/40";
  detailsEl.innerHTML = isProfileAdmin ? '<span class="admin-tag">Admin</span>' : '';
  actionsEl.innerHTML = "";

  if (isSelf || (request && request.status === "accepted") || isCreator || isAdmin) {
    detailsEl.innerHTML += `
      <p>Email: ${userData.email || "Not set"}</p>
      <p>City: ${userData.city || "Not set"}</p>
      <p>Phone: ${userData.phone || "Not set"}</p>
    `;
    if (request && request.status === "accepted" && !isSelf && !isAdmin && !isCreator) {
      actionsEl.innerHTML += `<button class="revoke-btn" id="revokeProfileBtn" data-request-id="${requestId}">Revoke Profile Access</button>`;
    }
  } else if (request && request.status === "pending") {
    actionsEl.innerHTML = `<button class="request-btn pending" id="requestProfileBtn" data-request-id="${requestId}" disabled>Pending...</button>`;
  } else if (!isSelf) {
    actionsEl.innerHTML += `<button class="request-btn" id="requestProfileBtn">Ask to see full profile</button>`;
  }

  if (isCreator) {
    if (commData.members.includes(uid) && !commData.admins?.includes(uid) && uid !== commData.creatorId) {
      actionsEl.innerHTML += `<button class="admin-btn" id="makeAdminBtn">Make Admin</button>`;
    }
    if (commData.members.includes(uid) && commData.admins?.includes(uid) && uid !== commData.creatorId) {
      actionsEl.innerHTML += `<button class="remove-admin-btn" id="removeAdminBtn">Remove Admin</button>`;
    }
    if (commData.members.includes(uid) && uid !== commData.creatorId) {
      actionsEl.innerHTML += `<button class="ban-btn" id="banUserBtn">Ban User</button>`;
    }
  } else if (isAdmin && uid !== commData.creatorId) {
    if (commData.members.includes(uid)) {
      actionsEl.innerHTML += `<button class="ban-btn" id="banUserBtn">Ban User</button>`;
    }
  }

  const requestBtn = document.getElementById("requestProfileBtn");
  if (requestBtn && !requestBtn.disabled) {
    requestBtn.addEventListener("click", () => requestProfileAccess(uid));
  }
  if (document.getElementById("makeAdminBtn")) {
    document.getElementById("makeAdminBtn").addEventListener("click", () => makeAdmin(communityId, uid));
  }
  if (document.getElementById("removeAdminBtn")) {
    document.getElementById("removeAdminBtn").addEventListener("click", () => removeAdmin(communityId, uid));
  }
  if (document.getElementById("banUserBtn")) {
    document.getElementById("banUserBtn").addEventListener("click", () => banUser(communityId, uid));
  }
  if (document.getElementById("revokeProfileBtn")) {
    document.getElementById("revokeProfileBtn").addEventListener("click", () => revokeProfileAccess(uid, document.getElementById("revokeProfileBtn").dataset.requestId));
  }
}

async function requestProfileAccess(targetId) {
  const user = auth.currentUser;
  const requestBtn = document.getElementById("requestProfileBtn");

  requestBtn.textContent = "Pending...";
  requestBtn.classList.add("pending");
  requestBtn.disabled = true;

  const requesterData = await fetchCurrentUserData();
  console.log(`Requester data for notification:`, requesterData);

  const requestDoc = await addDoc(collection(db, "profileRequests"), {
    requesterId: user.uid,
    targetId,
    status: "pending",
    createdAt: new Date()
  });

  requestBtn.dataset.requestId = requestDoc.id;

  await addDoc(collection(db, "notifications"), {
    userId: targetId,
    type: "profile_request",
    message: `${requesterData.name || "Someone"} wants to see your full profile!`,
    requestId: requestDoc.id,
    communityId: communityId, // Add this if you’re in a community context
    timestamp: new Date(),
    seen: false
  });
  updateNotificationBadge(targetId);

  alert("Profile access requested!");
}

// Update accept/decline to clean up properly (no pendingRequests references anymore)
async function acceptProfileRequest(requestId, userId) {
  const requestRef = doc(db, "profileRequests", requestId);
  await updateDoc(requestRef, { status: "accepted" });
  alert("Profile view request accepted!");
  closeModal("viewProfileViewRequestsModal");
  await updateProfileRequestsUI(userId);
  viewProfileViewRequests(userId);
}

async function declineProfileRequest(requestId, userId) {
  const requestRef = doc(db, "profileRequests", requestId);
  await deleteDoc(requestRef); // Deletes the doc—nice!
  alert("Profile view request declined!");
  closeModal("viewProfileViewRequestsModal");
  await updateProfileRequestsUI(userId);
  viewProfileViewRequests(userId);
}

async function revokeProfileAccess(targetId, requestId) {
  const requestRef = doc(db, "profileRequests", requestId);
  await deleteDoc(requestRef); // Deletes the doc—clean!
  alert("Profile access revoked!");
  closeModal("viewProfileModal");
  await viewProfile(targetId); // Reopens with fresh state
}

async function revokeProfileAccessFromModal(requestId, userId) {
  const requestRef = doc(db, "profileRequests", requestId);
  await deleteDoc(requestRef); // Deletes the doc—clean!
  alert("Profile access revoked!");
  closeModal("viewProfileViewRequestsModal");
  await updateProfileRequestsUI(userId);
  viewProfileViewRequests(userId); // Refreshes the requests modal
}

    async function viewProfileViewRequests(userId) {
      const modal = document.getElementById("viewProfileViewRequestsModal");
      const requestsList = document.getElementById("profileViewRequestsList");
      const grantedList = document.getElementById("grantedProfileAccessList");

      const pendingQ = query(collection(db, "profileRequests"), where("targetId", "==", userId), where("status", "==", "pending"));
      const pendingSnapshot = await getDocs(pendingQ);
      requestsList.innerHTML = pendingSnapshot.empty ? "<p>No pending profile view requests.</p>" : "";

      for (const doc of pendingSnapshot.docs) {
        const request = doc.data();
        const requesterData = await fetchUserData(request.requesterId);
        requestsList.innerHTML += `
          <div class="request-item" id="request-${doc.id}">
            <span>${requesterData.name} (${requesterData.username})</span>
            <button class="accept-btn" data-request-id="${doc.id}">Accept</button>
            <button class="decline-btn" data-request-id="${doc.id}">Decline</button>
          </div>
        `;
      }

      const grantedQ = query(collection(db, "profileRequests"), where("targetId", "==", userId), where("status", "==", "accepted"));
      const grantedSnapshot = await getDocs(grantedQ);
      grantedList.innerHTML = grantedSnapshot.empty ? "<p>No granted profile access.</p>" : "";

      for (const doc of grantedSnapshot.docs) {
        const request = doc.data();
        const requesterData = await fetchUserData(request.requesterId);
        grantedList.innerHTML += `
          <div class="request-item" id="granted-${doc.id}">
            <span>${requesterData.name} (${requesterData.username})</span>
            <button class="revoke-btn" data-request-id="${doc.id}">Revoke</button>
          </div>
        `;
      }

      document.querySelectorAll(".modal:not(#viewProfileViewRequestsModal)").forEach(m => m.style.display = "none");
      modal.style.display = "flex";
      modal.classList.remove("hidden");

      requestsList.querySelectorAll(".accept-btn").forEach(btn => {
        btn.addEventListener("click", () => acceptProfileRequest(btn.dataset.requestId, userId));
      });
      requestsList.querySelectorAll(".decline-btn").forEach(btn => {
        btn.addEventListener("click", () => declineProfileRequest(btn.dataset.requestId, userId));
      });
      grantedList.querySelectorAll(".revoke-btn").forEach(btn => {
        btn.addEventListener("click", () => revokeProfileAccessFromModal(btn.dataset.requestId, userId));
      });
    }

    async function makeAdmin(communityId, uid) {
      const commRef = doc(db, "communities", communityId);
      const commDoc = await getDoc(commRef);
      const admins = commDoc.data().admins || [];
      if (!admins.includes(uid) && commDoc.data().members.includes(uid) && uid !== commDoc.data().creatorId) {
        admins.push(uid);
        await updateDoc(commRef, { admins });
        alert("User is now an admin!");
        closeModal("viewProfileModal");
      } else {
        alert("User not found, already an admin, or is the creator!");
      }
    }

    async function removeAdmin(communityId, uid) {
      const commRef = doc(db, "communities", communityId);
      const commDoc = await getDoc(commRef);
      const admins = commDoc.data().admins || [];
      if (admins.includes(uid) && uid !== commDoc.data().creatorId) {
        const updatedAdmins = admins.filter(a => a !== uid);
        await updateDoc(commRef, { admins: updatedAdmins });
        alert("User admin status removed!");
        closeModal("viewProfileModal");
      } else {
        alert("User not an admin or is the creator!");
      }
    }

    async function banUser(communityId, uid) {
  const commRef = doc(db, "communities", communityId);
  const commDoc = await getDoc(commRef);
  const commData = commDoc.data();
  const bannedUsers = commData.bannedUsers || [];

  if (!bannedUsers.includes(uid) && commData.members.includes(uid) && uid !== commData.creatorId) {
    // Prompt admin for a ban reason
    const banReason = prompt("Please enter a reason for banning this user (e.g., 'Posting illegal things...'):");
    if (banReason === null || banReason.trim() === "") {
      alert("Ban canceled - no reason provided.");
      return; // Exit if no reason or canceled
    }

    // Add the user to banned list with reason
    bannedUsers.push(uid);
    const members = commData.members.filter(m => m !== uid);
    const admins = commData.admins ? commData.admins.filter(a => a !== uid) : [];

    // Store the ban reason in a separate subcollection or field
    await updateDoc(commRef, { 
      bannedUsers, 
      members, 
      admins,
      [`banReasons.${uid}`]: banReason.trim() // Store reason tied to user ID
    });
    resetCommDataCache(); // Add this
    alert("User banned!");
    closeModal("viewProfileModal");
  } else {
    alert("User not found, already banned, or is the creator!");
  }
}

    async function unbanUser(communityId, uid) {
      const commRef = doc(db, "communities", communityId);
      const commDoc = await getDoc(commRef);
      const bannedUsers = commDoc.data().bannedUsers || [];
      if (bannedUsers.includes(uid)) {
        const updatedBanned = bannedUsers.filter(b => b !== uid);
        const members = commDoc.data().members.concat(uid);
        await updateDoc(commRef, { bannedUsers: updatedBanned, members });
        alert("User unbanned!");
        closeModal("viewBannedModal");
        viewBannedUsers(communityId);
      } else {
        alert("User not banned!");
      }
    }

    let currentMembers = [];
    async function viewMembers(communityId) {
      const modal = document.getElementById("viewMembersModal");
      const membersList = document.getElementById("membersList");
      const seeMoreBtn = document.getElementById("seeMoreMembersBtn");
      const memberSearch = document.getElementById("memberSearch");

      const commRef = doc(db, "communities", communityId);
      const commDoc = await getDoc(commRef);
      currentMembers = commDoc.data().members || [];

      lastMemberDoc = null;
      membersList.innerHTML = "";
      await loadMoreMembers();

      document.querySelectorAll(".modal:not(#viewMembersModal)").forEach(m => m.style.display = "none");
      modal.style.display = "flex";
      modal.classList.remove("hidden");

      seeMoreBtn.onclick = () => loadMoreMembers();
      memberSearch.oninput = debounce((e) => searchMembers(e.target.value), 300);
    }

    async function loadMoreMembers() {
      const membersList = document.getElementById("membersList");
      const seeMoreBtn = document.getElementById("seeMoreMembersBtn");
      const batch = currentMembers.slice(lastMemberDoc ? membersList.children.length : 0, (lastMemberDoc ? membersList.children.length : 0) + itemsPerPage);
      if (batch.length === 0) return;

      const q = query(collection(db, "users"), where("__name__", "in", batch));
      const snapshot = await getDocs(q);
      lastMemberDoc = snapshot.docs[snapshot.docs.length - 1];

      for (const doc of snapshot.docs) {
        const userData = doc.data();
        const itemId = `member-${doc.id}`;
        if (!document.getElementById(itemId)) {
          const memberDiv = document.createElement("div");
          memberDiv.className = "user-item";
          memberDiv.id = itemId;
          memberDiv.innerHTML = `
            <img src="${userData.profilePhoto || 'https://via.placeholder.com/30'}" alt="Profile">
            <span class="username" data-uid="${doc.id}">${userData.name}</span>
          `;
          membersList.appendChild(memberDiv);
          memberDiv.querySelector(`.username[data-uid="${doc.id}"]`).addEventListener("click", () => viewProfile(doc.id));
        }
      }

      seeMoreBtn.style.display = membersList.children.length >= currentMembers.length ? "none" : "block";
    }

    async function searchMembers(searchTerm) {
      const membersList = document.getElementById("membersList");
      const seeMoreBtn = document.getElementById("seeMoreMembersBtn");
      membersList.innerHTML = "";
      seeMoreBtn.style.display = "none";

      if (!searchTerm) {
        lastMemberDoc = null;
        return loadMoreMembers();
      }

      const filteredMembers = currentMembers.filter(uid => {
        const user = userDataCache[uid];
        return user && (user.name.toLowerCase().includes(searchTerm.toLowerCase()) || user.username.toLowerCase().includes(searchTerm.toLowerCase()));
      });
      const userPromises = filteredMembers.slice(0, itemsPerPage).map(uid => fetchUserData(uid));
      const users = await Promise.all(userPromises);

      users.forEach(user => {
        const itemId = `member-${user.uid}`;
        const memberDiv = document.createElement("div");
        memberDiv.className = "user-item";
        memberDiv.id = itemId;
        memberDiv.innerHTML = `
          <img src="${user.profilePhoto || 'https://via.placeholder.com/30'}" alt="Profile">
          <span class="username" data-uid="${user.uid}">${user.name}</span>
        `;
        membersList.appendChild(memberDiv);
        memberDiv.querySelector(`.username[data-uid="${user.uid}"]`).addEventListener("click", () => viewProfile(user.uid));
      });
    }

    async function viewBannedUsers(communityId) {
  const modal = document.getElementById("viewBannedModal");
  const bannedList = document.getElementById("bannedList");
  const seeMoreBtn = document.getElementById("seeMoreBannedBtn");
  const bannedSearch = document.getElementById("bannedSearch");

  const commRef = doc(db, "communities", communityId);
  const commDoc = await getDoc(commRef);
  const commData = commDoc.data();
  const bannedUsers = commData.bannedUsers || [];

  modal.querySelector(".modal-content").innerHTML = `
    <h2>Banned Users</h2>
    <input type="text" id="bannedSearch" placeholder="Search banned users...">
    <div id="bannedMessages" class="banned-messages"></div>
    <div id="bannedList" class="user-list"></div>
    <button id="seeMoreBannedBtn">See More</button>
    <button id="closeBannedBtn">Close</button>
  `;

  const messagesDiv = modal.querySelector("#bannedMessages");
  const appealsQ = query(collection(db, "banAppeals"), where("communityId", "==", communityId));
  const appealsSnapshot = await getDocs(appealsQ);
  if (!appealsSnapshot.empty) {
    messagesDiv.innerHTML = "<h3>Appeal Messages</h3>";
    for (const doc of appealsSnapshot.docs) {
      const appeal = doc.data();
      const userData = await fetchUserData(appeal.userId);
      messagesDiv.innerHTML += `
        <div class="appeal-item" data-appeal-id="${doc.id}">
          <p><strong>${userData.name || "Unknown"}:</strong> ${appeal.message}</p>
          <span>${new Date(appeal.timestamp.toDate()).toLocaleString()}</span>
          <button class="delete-appeal-btn" data-appeal-id="${doc.id}">Delete</button>
        </div>
      `;
    }
    messagesDiv.querySelectorAll(".delete-appeal-btn").forEach(btn => {
      btn.addEventListener("click", async () => {
        if (confirm("Delete this appeal?")) {
          const appealId = btn.dataset.appealId;
          await deleteDoc(doc(db, "banAppeals", appealId));
          messagesDiv.querySelector(`.appeal-item[data-appeal-id="${appealId}"]`).remove();
          if (!messagesDiv.querySelector(".appeal-item")) {
            messagesDiv.innerHTML = "<p>No appeals yet.</p>";
          }
        }
      });
    });
  } else {
    messagesDiv.innerHTML = "<p>No appeals yet.</p>";
  }

  if (bannedUsers.length === 0) {
    bannedList.innerHTML = "<p>No banned users.</p>";
    seeMoreBtn.style.display = "none";
  } else {
    lastBannedDoc = null;
    bannedList.innerHTML = "";
    await loadMoreBanned(bannedUsers);
    // Only show "See More" if more than 10 banned users
    seeMoreBtn.style.display = bannedUsers.length > 10 ? "block" : "none";
  }

  document.querySelectorAll(".modal:not(#viewBannedModal)").forEach(m => m.style.display = "none");
  modal.style.display = "flex";
  modal.classList.remove("hidden");

  seeMoreBtn.onclick = () => loadMoreBanned(bannedUsers);
  bannedSearch.oninput = debounce((e) => searchBanned(bannedUsers, e.target.value), 300);
  modal.querySelector("#closeBannedBtn").addEventListener("click", () => closeModal("viewBannedModal"));
}

async function loadMoreBanned(bannedUsers) {
  const bannedList = document.getElementById("bannedList");
  const seeMoreBtn = document.getElementById("seeMoreBannedBtn");
  const batch = bannedUsers.slice(lastBannedDoc ? bannedList.children.length : 0, (lastBannedDoc ? bannedList.children.length : 0) + itemsPerPage);
  if (batch.length === 0) return;

  const q = query(collection(db, "users"), where("__name__", "in", batch));
  const snapshot = await getDocs(q);
  lastBannedDoc = snapshot.docs[snapshot.docs.length - 1];

  for (const doc of snapshot.docs) {
    const userData = doc.data();
    const itemId = `banned-${doc.id}`;
    if (!document.getElementById(itemId)) {
      bannedList.innerHTML += `
        <div class="user-item" id="${itemId}">
          <img src="${userData.profilePhoto || 'https://via.placeholder.com/30'}" alt="Profile">
          <span class="username" data-uid="${doc.id}">${userData.name}</span>
          <button class="remove-member-btn" data-uid="${doc.id}">Remove as Member</button>
          <button class="unban-btn" data-uid="${doc.id}">Unban</button>
        </div>
      `;
      bannedList.querySelector(`#${itemId} .username`).addEventListener("click", () => viewProfile(doc.id));
      bannedList.querySelector(`#${itemId} .remove-member-btn`).addEventListener("click", () => removeAsMember(communityId, doc.id));
      bannedList.querySelector(`#${itemId} .unban-btn`).addEventListener("click", () => unbanUser(communityId, doc.id));
    }
  }

  seeMoreBtn.style.display = bannedList.children.length >= bannedUsers.length ? "none" : "block";
}

async function removeAsMember(communityId, uid) {
  const commRef = doc(db, "communities", communityId);
  const commDoc = await getDoc(commRef);
  const commData = commDoc.data();
  const bannedUsers = commData.bannedUsers || [];

  if (bannedUsers.includes(uid)) {
    const updatedBanned = bannedUsers.filter(b => b !== uid);
    await updateDoc(commRef, { bannedUsers: updatedBanned });

    // Update user's communityIds
    const userRef = doc(db, "users", uid);
    const userDoc = await getDoc(userRef);
    const userData = userDoc.data();
    const updatedCommunityIds = (userData.communityIds || []).filter(id => id !== communityId);
    await updateDoc(userRef, { communityIds: updatedCommunityIds });

    alert("User removed as member (no longer banned)!");
    closeModal("viewBannedModal");
    viewBannedUsers(communityId); // Refresh banned list

    // If this is the current user, refresh their community list
    if (uid === auth.currentUser.uid && typeof loadYourCommunities === "function") {
      loadYourCommunities({ ...userData, communityIds: updatedCommunityIds });
    }
  } else {
    alert("User not banned!");
  }
}

async function searchBanned(bannedUsers, searchTerm) {
  const bannedList = document.getElementById("bannedList");
  const seeMoreBtn = document.getElementById("seeMoreBannedBtn");
  bannedList.innerHTML = "";
  seeMoreBtn.style.display = "none";

  if (!searchTerm) {
    lastBannedDoc = null;
    return loadMoreBanned(bannedUsers);
  }

  const filteredBanned = bannedUsers.filter(uid => {
    const user = userDataCache[uid];
    return user && (user.name.toLowerCase().includes(searchTerm.toLowerCase()) || user.username.toLowerCase().includes(searchTerm.toLowerCase()));
  });
  const userPromises = filteredBanned.slice(0, itemsPerPage).map(uid => fetchUserData(uid));
  const users = await Promise.all(userPromises);

  users.forEach(user => {
    const itemId = `banned-${user.uid}`;
    bannedList.innerHTML += `
      <div class="user-item" id="${itemId}">
        <img src="${user.profilePhoto || 'https://via.placeholder.com/30'}" alt="Profile">
        <span class="username" data-uid="${user.uid}">${user.name}</span>
        <button class="unban-btn" id="unban-${user.uid}">Unban</button>
      </div>
    `;
    bannedList.querySelector(`#${itemId} .username`).addEventListener("click", () => viewProfile(user.uid));
    document.getElementById(`unban-${user.uid}`).addEventListener("click", () => unbanUser(communityId, user.uid));
  });
}

async function viewCommunities(userId) {
  const modal = document.getElementById("viewCommunitiesModal");
  const communitiesList = document.getElementById("communitiesList");
  const closeBtn = document.getElementById("closeCommunitiesBtn");

  communitiesList.innerHTML = '<div class="loading">Loading...</div>';
  modal.style.display = "flex";
  modal.classList.remove("hidden");

  const userRef = doc(db, "users", userId);
  const userDoc = await getDoc(userRef);
  const communityIds = userDoc.data().communityIds || [];

  if (communityIds.length === 0) {
    communitiesList.innerHTML = "<p>You’re not in any communities yet!</p>";
  } else {
    communitiesList.innerHTML = "";
    const commPromises = communityIds.map(id => getDoc(doc(db, "communities", id)));
    const commDocs = await Promise.all(commPromises);

    commDocs.forEach(doc => {
      if (doc.exists()) {
        const commData = doc.data();
        const isBanned = (commData.bannedUsers || []).includes(userId);
        if (!isBanned) { // Only show if not banned
          const commDiv = document.createElement("div");
          commDiv.className = "community-item";
          commDiv.innerHTML = `
            <a href="./community.html?id=${doc.id}">${commData.name || "Unnamed"}</a>
          `;
          communitiesList.appendChild(commDiv);
        }
      }
    });

    if (!communitiesList.children.length) {
      communitiesList.innerHTML = "<p>No active communities found.</p>";
    }
  }

  closeBtn.onclick = () => {
    modal.style.display = "none";
    modal.classList.add("hidden");
  };
}

async function updateNotificationBadge(userId) {
  const now = Date.now();
  let lastCheck = parseInt(sessionStorage.getItem("lastBadgeCheck")) || 0;
  let cachedCount = parseInt(sessionStorage.getItem("notificationCount")) || 0;
  const lastTimestamp = sessionStorage.getItem("lastNotifTimestamp") ? new Date(sessionStorage.getItem("lastNotifTimestamp")) : new Date(0);

  // Throttle to 30 seconds
  if (now - lastCheck < 30000) {
    const badge = document.getElementById("notificationCount");
    badge.textContent = cachedCount;
    badge.style.display = cachedCount > 0 ? "inline" : "none";
    console.log("Using cached badge count, bro!");
    return;
  }

  // Fetch only new notifications since last timestamp
  const q = query(
    collection(db, "notifications"),
    where("userId", "==", userId),
    where("seen", "==", false),
    where("timestamp", ">", lastTimestamp),
    orderBy("timestamp", "asc")
  );
  const snapshot = await getDocs(q);
  
  // Add new unseen count to cached total
  const newUnseenCount = snapshot.size;
  cachedCount += newUnseenCount;

  // Update last timestamp if there are new notifications
  if (!snapshot.empty) {
    const latestNotif = snapshot.docs[snapshot.docs.length - 1].data();
    sessionStorage.setItem("lastNotifTimestamp", latestNotif.timestamp.toDate().toISOString());
  }

  sessionStorage.setItem("notificationCount", cachedCount);
  sessionStorage.setItem("lastBadgeCheck", now);

  const badge = document.getElementById("notificationCount");
  badge.textContent = cachedCount;
  badge.style.display = cachedCount > 0 ? "inline" : "none";
}

    async function openNotificationsModal(userId) {
  const modal = document.getElementById("notificationsModal");
  const notificationList = document.getElementById("notificationList");
  const modalCount = document.getElementById("modalNotificationCount");
  const communityFilter = document.getElementById("communityFilter");
  const goToCommunityBtn = document.getElementById("goToCommunityBtn");
  notificationList.innerHTML = '<div class="loading">Loading...</div>';

  document.querySelectorAll(".modal:not(#notificationsModal)").forEach(m => m.style.display = "none");
  modal.style.display = "flex";
  modal.classList.remove("hidden");

  const userRef = doc(db, "users", userId);
  const userDoc = await getDoc(userRef);
  const communityIds = userDoc.data().communityIds || [];
  const communityPromises = communityIds.map(id => getDoc(doc(db, "communities", id)));
  const communityDocs = await Promise.all(communityPromises);
  const communities = communityDocs
    .filter(doc => doc.exists())
    .map(doc => ({ id: doc.id, name: doc.data().name || "Unnamed Community" }));

  communityFilter.innerHTML = '<option value="all">All Communities</option>';
  communities.forEach(comm => {
    const option = document.createElement("option");
    option.value = comm.id;
    option.textContent = comm.name;
    communityFilter.appendChild(option);
  });

  async function loadNotifications() {
    const selectedCommunity = communityFilter.value;
    let q;
    if (selectedCommunity === "all") {
      q = query(collection(db, "notifications"), where("userId", "==", userId), orderBy("timestamp", "desc"), limit(10));
    } else {
      q = query(collection(db, "notifications"), where("userId", "==", userId), where("communityId", "==", selectedCommunity), orderBy("timestamp", "desc"), limit(10));
    }

    const snapshot = await getDocs(q);
    notificationList.innerHTML = "";

    const unseenCount = snapshot.docs.filter(doc => !doc.data().seen).length;
    modalCount.textContent = unseenCount;

    for (const doc of snapshot.docs) {
      const notif = doc.data();
      const timestamp = new Date(notif.timestamp.toDate()).toLocaleString();
      let displayMessage = notif.message;
      if (notif.communityId && notif.type !== "ban_appeal") {
        const communityName = communities.find(c => c.id === notif.communityId)?.name || "Unknown Community";
        displayMessage += ` (${communityName})`;
      }

      const notifDiv = document.createElement("div");
      notifDiv.className = `notification-item ${notif.seen ? 'seen' : ''}`;
      notifDiv.innerHTML = `
        <span>${displayMessage}</span>
        <span class="timestamp">${timestamp}</span>
        ${notif.postId ? `<button class="copy-id-btn2" data-post-id="${notif.postId}">Copy ID (Search Post)</button>` : ""}
        <button class="mark-seen-btn2" data-id="${doc.id}" ${notif.seen ? 'disabled' : ''}>${notif.seen ? 'Seen' : 'Mark as Seen'}</button>
        ${notif.type === "ban_appeal" && !notif.appealSubmitted ? `
          <form class="ban-appeal-form" data-id="${doc.id}">
            <textarea placeholder="Explain why this ban might be an error..." required></textarea>
            <button type="submit">Send Appeal</button>
          </form>
        ` : ""}
      `;
      notificationList.appendChild(notifDiv);

      if (notif.postId) {
        notifDiv.querySelector(".copy-id-btn2").addEventListener("click", (e) => {
          e.stopPropagation();
          copyPostId(notif.postId);
        });
      }
      const markSeenBtn = notifDiv.querySelector(".mark-seen-btn2");
      if (!notif.seen) {
        markSeenBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          markNotificationSeen(doc.id);
        });
      } else {
        markSeenBtn.classList.add("disabled");
      }
      if (notif.type === "ban_appeal" && !notif.appealSubmitted) {
        const appealForm = notifDiv.querySelector(".ban-appeal-form");
        appealForm.addEventListener("submit", async (e) => {
          e.preventDefault();
          const text = appealForm.querySelector("textarea").value.trim();
          if (text) {
            await addDoc(collection(db, "banAppeals"), {
              userId: userId,
              communityId: notif.communityId,
              message: text,
              timestamp: new Date(),
              notificationId: doc.id
            });
            await updateDoc(doc.ref, { appealSubmitted: true });
            alert("Appeal sent!");
            openNotificationsModal(userId); // Refresh
          }
        });
      }
      notifDiv.addEventListener("click", () => {
        if (notif.postId && notif.communityId) {
          if (notif.communityId !== communityId) {
            window.location.href = `/community.html?id=${notif.communityId}#post-${notif.postId}`;
          } else {
            window.location.hash = `post-${notif.postId}`;
            loadPosts(communityId, currentPage).then(() => {
              const postComments = document.getElementById(`comments-${notif.postId}`);
              if (postComments) {
                postComments.style.display = "block";
                toggleComments(notif.postId);
              }
              closeModal("notificationsModal");
            });
          }
        }
      });
    }

    goToCommunityBtn.style.display = (selectedCommunity !== "all" && selectedCommunity !== communityId) ? "block" : "none";
    goToCommunityBtn.onclick = () => {
      window.location.href = `./community.html?id=${selectedCommunity}`;
    };
  }

  await loadNotifications();
  communityFilter.onchange = loadNotifications;
}

async function markNotificationSeen(notifId) {
  const notifRef = doc(db, "notifications", notifId);
  const userId = auth.currentUser.uid;

  // Update Firestore
  await updateDoc(notifRef, { seen: true });

  // Update UI immediately
  const button = document.querySelector(`.mark-seen-btn2[data-id="${notifId}"]`);
  if (button) {
    button.disabled = true;
    button.textContent = "Seen"; // Optional: Change text for clarity
    button.classList.add("disabled"); // Optional: Style it
  }

  updateNotificationBadge(userId);
  openNotificationsModal(userId);
}

    async function clearNotifications() {
  const communityFilter = document.getElementById("communityFilter");
  const selectedCommunity = communityFilter.value;
  const userId = auth.currentUser.uid;

  let confirmMessage = selectedCommunity === "all" 
    ? "Clear all notifications?" 
    : `Clear notifications for ${communityFilter.options[communityFilter.selectedIndex].text} only?`;
  
  if (confirm(confirmMessage)) {
    let q;
    if (selectedCommunity === "all") {
      q = query(collection(db, "notifications"), where("userId", "==", userId));
    } else {
      q = query(collection(db, "notifications"), 
                where("userId", "==", userId), 
                where("communityId", "==", selectedCommunity));
    }

    const snapshot = await getDocs(q);
    const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));
    await Promise.all(deletePromises);
    updateNotificationBadge(userId);
    openNotificationsModal(userId);
  }
}

    async function totalComments(postId) {
      const q = query(collection(db, "communities", communityId, "posts", postId, "comments"));
      const snapshot = await getDocs(q);
      return snapshot.size;
    }

    async function totalReplies(postId, commentId) {
      const q = query(collection(db, "communities", communityId, "posts", postId, "comments", commentId, "replies"));
      const snapshot = await getDocs(q);
      return snapshot.size;
    }

    let commDataCache = null;

async function getCommData() {
  if (commDataCache) {
    console.log("Using cached community data!");
    return commDataCache;
  }
  const commRef = doc(db, "communities", communityId);
  const commDoc = await getDoc(commRef);
  commDataCache = commDoc.data();
  console.log("Fetched fresh community data!");
  return commDataCache;
}

// Reset cache when needed (e.g., after updates like banning users)
function resetCommDataCache() {
  commDataCache = null;
}

    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }
  </script>
</body>
</html>